A Byte of Python (Russian)
Версия 2.02
Swaroop C H (Перевод: Владимир Смоляр)
26 апреля 2020
Оглавление
1 Обложка 1
1.1 «УкусПитона»–«AByteofPython»по-русски . . . . . . . . . . . . . . . . . 1
1.2 Кточитает«AByteofPython»? . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
1.3 Лицензия . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5
1.4 Читать . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5
1.5 Купитькнигу . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
1.6 Скачать . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
1.7 Книганавашемродномязыке . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
2 Переводы 7
2.1 Доступныепереводы переводы . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
3 Предисловие 16
3.1 Длякогоэтакнига . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16
3.2 Немногоистории . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16
3.3 Состояниекниги . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
3.4 Официальнаявеб-страница . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
3.5 Кразмышлению . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
4 Введение 19
4.1 ОсобенностиPython . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
4.2 Python2против3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
4.3 Чтоговорятпрограммисты . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
5 Установка 24
5.1 УстановкавGNU/LinuxиBSD . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24
5.2 УстановкавWindows . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
5.3 ДляпользователейMacOSX . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
5.4 Резюме . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
i6 Первые шаги 28
6.1 Использованиекоманднойстрокиинтерпретатора . . . . . . . . . . . . . . . 28
6.2 Выборредактора . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
6.3 Использованиепрограммныхфайлов . . . . . . . . . . . . . . . . . . . . . . . 30
6.4 Получениепомощи . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34
6.5 Резюме . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35
7 Основы 36
7.1 Комментарии . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36
7.2 Литеральныеконстанты . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37
7.3 Числа . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37
7.4 Строки . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37
7.5 Переменные . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40
7.6 Именаидентификаторов . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41
7.7 Типыданных . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41
7.8 Объекты . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41
7.9 Логическиеифизическиестроки . . . . . . . . . . . . . . . . . . . . . . . . . 43
7.10 Отступы . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44
7.11 Резюме . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46
8 Операторы и выражения 47
8.1 Операторы . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47
8.2 Порядоквычисления . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51
8.3 Изменениепорядкавычисления . . . . . . . . . . . . . . . . . . . . . . . . . . 53
8.4 Ассоциативность . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53
8.5 Выражения . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53
8.6 Резюме . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54
9 Поток команд 55
9.1 Операторif . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 55
9.2 Операторwhile . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58
9.3 Циклfor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59
9.4 Операторbreak . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61
9.5 Операторcontinue . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62
9.6 Резюме . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63
10 Функции 64
10.1 Параметрыфункций . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65
10.2 Локальныепеременные . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66
10.3 Зарезервированноеслово«global» . . . . . . . . . . . . . . . . . . . . . . . . . 67
10.4 Зарезервированноеслово«nonlocal» . . . . . . . . . . . . . . . . . . . . . . . 68
10.5 Значенияаргументовпоумолчанию . . . . . . . . . . . . . . . . . . . . . . . 69
10.6 Ключевыеаргументы . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70
10.7 Переменноечислопараметров . . . . . . . . . . . . . . . . . . . . . . . . . . . 71
10.8 Толькоключевыепараметры . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72
ii10.9 Оператор«return» . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73
10.10 Строкидокументации . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74
10.11 Аннотации . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75
10.12 Резюме . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75
11 Модули 76
11.1 Файлыбайткода.pyc . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 78
11.2 Операторfrom…import… . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 78
11.3 Имямодуля–__name__ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79
11.4 Созданиесобственныхмодулей . . . . . . . . . . . . . . . . . . . . . . . . . . 80
11.5 Функцияdir . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 82
11.6 Пакеты . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83
11.7 Резюме . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84
12 Структуры данных 85
12.1 Список . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 85
12.2 Краткоевведениевобъектыиклассы . . . . . . . . . . . . . . . . . . . . . . . 85
12.3 Кортеж . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 88
12.4 Словарь . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89
12.5 Последовательности . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 92
12.6 Множество . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 94
12.7 Ссылки . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 95
12.8 Ещёостроках . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96
12.9 Резюме . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 97
13 Решение задач 98
13.1 Задача . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 98
13.2 Решение . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 99
13.3 Втораяверсия . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101
13.4 Третьяверсия . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103
13.5 Четвёртаяверсия . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105
13.6 Дополнительныеусовершенствования . . . . . . . . . . . . . . . . . . . . . . 106
13.7 Процессразработкипрограммногообеспечения . . . . . . . . . . . . . . . . 107
13.8 Резюме . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 107
14 Объектно-ориентированное программирование 108
14.1 self . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109
14.2 Классы . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109
14.3 Методыобъектов . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 110
14.4 Метод __init__ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 111
14.5 Переменныеклассаиобъекта . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112
14.6 Наследование . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115
14.7 Метаклассы . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 118
14.8 Резюме . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 120
iii15 Ввод-вывод 121
15.1 Вводотпользователя . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 121
15.2 Файлы . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 123
15.3 Pickle . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 124
15.4 Резюме . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125
16 Исключения 126
16.1 Ошибки . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 126
16.2 Исключения . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 126
16.3 Обработкаисключений . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127
16.4 Вызовисключения . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 128
16.5 Try..Finally . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129
16.6 Операторwith . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 130
16.7 Резюме . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131
17 Стандартная библиотека 132
17.1 Модульsys . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 132
17.2 Модульlogging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 133
17.3 Серия«Модульнедели» . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 135
17.4 Резюме . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 135
18 Дополнительно 136
18.1 Передачакортежей . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 136
18.2 Специальныеметоды . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 137
18.3 Блокиводновыражение . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 137
18.4 Lambda-формы . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 138
18.5 Генераторысписков . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 138
18.6 Передачакортежейисловарейвфункции . . . . . . . . . . . . . . . . . . . . 139
18.7 execиeval . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 140
18.8 Операторassert . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 140
18.9 Функцияrepr . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 141
18.10 Управляющиепоследовательности . . . . . . . . . . . . . . . . . . . . . . . . 141
18.11 Необрабатываемыестроки . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 142
18.12 Резюме . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 142
19 Что дальше 143
19.1 Упражнения . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 144
19.2 Примерыпрограмм . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 144
19.3 Вопросыиответы . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 144
19.4 Советыирекомендации . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 145
19.5 Учебники . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 145
19.6 Видео . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 145
19.7 Обсуждение . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 145
19.8 Новости . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 145
19.9 Установкабиблиотек . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 146
iv19.10 Графическиепрограммы . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 146
19.11 РезюмепоинструментамГИП . . . . . . . . . . . . . . . . . . . . . . . . . . . 147
19.12 Различныереализации . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 147
19.13 Функциональное программирование (для хорошо подготовленных чита-
телей). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 148
19.14 Резюме . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 148
20 Приложение: FLOSS 149
20.1 Free/LibreandOpenSourceSoftware(FLOSS) . . . . . . . . . . . . . . . . . . . 149
21 Приложение: о книге 152
21.1 Колофон . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 152
21.2 Обавторе . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 153
22 Приложение: История версий 154
23 Приложение: Инструкция по переводу 158
vОбложка
1.1
«Укус Питона» – «A Byte of Python» по-русски
Примечание: Отавтораперевода
Передвамипереводпопулярнойкниги «A Byte of Python»1нарусскийязык.
Авторкниги– Swaroop Chitlur .
Авторрусскогоперевода– Владимир Смоляр2
Настоящийпереводоснованнаверсии2.0оригинальнойкнигииимеетверсию 2.0.2
Свежуюверсиюоригиналакнигиможнопросмотреть здесь.
«A Byte of Python» – это свободная книга по программированию на языке Python. Она
можетслужитьучебнымпособиемилируководствомпоязыкуPythonдляначинающей
аудитории. Если ваши знания о компьютере ограничиваются тем, как сохранять тексто-
выефайлы,этакнигадлявас.
Настоящая книга описывает язык Python 3, несмотря на то, что Python 2 всё ещё более
распространён(болеедетальнообэтомсм.раздел Python 2 против 3 ).
1.2
Кто читает «A Byte of Python»?
Вотчтолюдиговорятонастоящейкниге:
«Лучшее, что мне удалось найти – «A Byte of Python» – просто блестящая книга для на-
чинающих. Она хорошо написана, основные понятия доступно объясняются на наглядных
примерах.»
–SyedTalal(19лет)
1Названиекниги«AByteofPython»(дословно–«БайтПитона»)по-английскизвучиттакже,каки«A
BiteofPython»–«УкусПитона»( прим.перев. )
2Сообщения об ошибках и предложения по улучшению перевода просьба присылать на e-mail:
v_2e@ukr.net.
1A Byte of Python (Russian), Версия 2.02
«Это лучший учебник для начинающих из всех, что я видел! Спасибо вам за ваш труд.»
–WaltMichalik(wmich50-at-theramp-dot-net)
«Вы написали лучший учебник по Python из тех, что я встречал в Сети. Отличная работа.
Спасибо!»
–JoshuaRobin(joshrob-at-poczta-dot-onet-dot-pl)
«Превосходный вводный курс в программирование #Python для начинающих»
–ShanRajasekaran
«Привет! Я из Доминиканской Республики. Меня зовут Павел. Недавно я прочитал вашу кни-
гу «A Byte of Python», и нахожу её замечательной :). Я многому научился на приведённых
примерах. Ваша книга – отличный помощник таким новичкам, как я…»
–PavelSimo(pavel-dot-simo-at-gmail-dot-com)
«Недавно я закончил читать «A Byte of Python» и подумал, что я обязательно должен побла-
годарить вас. Было грустно дойти до последних страниц, так как это означало возвращение
к тупым и скучным руководствам O’Reilly или чего-то подобного для изучения Python. В лю-
бом случае я очень благодарен вам за вашу книгу.»
–SamuelYoung(sy-one-three-seven-at-gmail-dot-com)
«Уважаемый Swaroop, я прохожу курс, который ведёт преподаватель, совсем не заинтересо-
ванный в преподавании. Мы пользуемся книгой «Изучаем Python», второе издание O’Reilly. Но
она совсем не для начинающих студентов, практически без каких-либо знаний о программи-
ровании, и преподавателя, который должен работать кем-нибудь другим. Огромное спасибо
вам за вашу книгу. Без неё я так бы никогда ничего и не понял о Python и программировании
вообще. Тысяча благодарностей! Вы умеете «разбить мысль на части» до такого уровня,
чтобы начинающим было легко понять, а далеко не каждый на это способен.»
–JosephDuarte(jduarte1-at-cfl-dot-rr-dot-com)
«Я в восторге от вашей книги! Это самый лучший учебник по Python, кроме того полезный
и как справочник. Просто блестяще! Настоящий шедевр! Так держать!»
1.2. Кто читает «A Byte of Python»? 2A Byte of Python (Russian), Версия 2.02
–Chris-AndréSommerseth
«Пишу вам, чтобы поблагодарить за написание и публикацию в сети «A Byte of Python». Я
предпринимал попытки изучить Python в течение нескольких месяцев, прежде чем наткнул-
ся на вашу книгу. И хотя я достиг небольших успехов с pyGame, мне никак не удавалось за-
кончить программу.
Благодаря вашему упрощению многих понятий, Python теперь кажется мне вполне дости-
жимой целью. Кажется, теперь я наконец-то освоил основы и могу продолжать идти к своей
настоящей цели – разработке игр.
…
Ещё раз спасибо ОГРОМНОЕ за размещение такого структурированного и полезного путе-
водителя по основам программирования в Интернете. Он провёл меня через ООП, разъяснив
то, что не смогли разъяснить два учебника.»
–MattGallivan(m-underscore-gallivan12-at-hotmail-dot-com)
«Я бы хотел поблагодарить вас за вашу книгу «A byte of python», которая кажется мне са-
мым лучшим средством для изучения Python. Мне 15 лет, я живу в Египте. Зовут меня Ах-
мед. Python – мой второй язык программирования. В школе я изучал Visual Basic 6, но мне
он не понравился, а изучать Python мне по-настоящему нравится. Мне удалось написать
программу «Адресная книга». Теперь я буду больше программировать сам и читать чужие
программы на Python (если вы подскажете мне подходящий их источник). Также я намерен
приступить к изучению Java, и если бы вы могли порекомендовать мне пособие по Java, столь
же хорошее, как ваше, это бы мне очень помогло. Спасибо.»
–AhmedMohammed(sedo-underscore-91-at-hotmail-dot-com)
«Замечательным источником для начинающих, желающих узнать больше о Python может
послужить пособие «A Byte of Python», написанное Swaroop C H в 110 страницах. Оно отлич-
но написано, легко воспринимается и, возможно, это лучшее из существующих введение в
программирование на Python»
–DrewAmesвстатье«ScriptingScribus»,опубликованнойнаLinux.com
«Вчера я прошёл почти весь «Byte of Python» на своём Nokia N800, и он показался мне наиболее
лёгким и лаконичным введением в Python из всех, что я встречал. Настоятельно рекомендую
его как отправную точку для изучающих Python.»
–JasonDelportвсвоёмблоге
1.2. Кто читает «A Byte of Python»? 3A Byte of Python (Russian), Версия 2.02
«Byte of Vim и Python», написанные @swaroopch, на мой взгляд, наилучшие образцы техниче-
ской документации. Прекрасно читаются #FeelGoodFactor
–SurendranговоритвТвиттере
«»Byte of python» – безусловно лучший»
(в ответ на вопрос «Посоветуйте хороший и недорогой ресурс для изучения основ Python.»)
–JustinLoveTrueпишетнастраницеFacebook
«Книга «Byte of Python» очень помогла. Спасибо, bigtime :)»
–Chinmay
«Всегда был поклонником «A Byte of Python» – написанного как для новичков, так и для опыт-
ных программистов.»
–PatrickHarrington,вответенаStackOverflow
Даже NASA
ЭтакнигаиспользуетсядажевНАСА!Еюпользуютсявлабораторииреактив-
ногодвижения3врамкахпроекта«Сетьдальнейкосмическойсвязи»4.
Учебные курсы
Этакнигаиспользуетсявкачествеучебногоматериалавразличныхучебных
заведениях
•Курс «Принципы языков программирования» в университете Vrije, Ам-
стердам
•Курс«Основымашинныхвычислений»вКалифорнийскомУниверсите-
тевДэвисе
•Курс«ПрограммированиенаPython»вГарвардскомуниверситете
•Курс«Введениевпрограммирование»вУниверситетеЛидса
•Курс«Введениевразработкуприложений»вБостонскомУниверситете
3JetPropulsionLaboratory (прим.перев. )
4DeepSpaceNetwork (прим.перев. )
1.2. Кто читает «A Byte of Python»? 4A Byte of Python (Russian), Версия 2.02
•Курс«Методыинформационныхтехнологийвметеорологии»вУнивер-
ситетеОклахомы
•Курс«Обработкагеоданных»вУниверситетештатаМичиган
•Курс«Многоагентныесистемысемантическойпаутины»вУниверситете
Эдинбурга
1.3
Лицензия
Настоящаякнигараспространяетсянаусловияхлицензии CreativeCommonsAttribution-
ShareAlike3.0Unported .
Этоозначает,что:
•Выимеетеправокопировать,распространятьипередаватьеёдругим
•Выимеетеправоиспользоватьфрагментыэтойкнигивсвоихтекстах
•Выимеетеправоиспользоватьеёвкоммерческихцелях
Внимание:
•Припродажеэлектроннойилипечатнойверсииэтойкнигивеёописаниинеобхо-
димовявнойформеуказать,чтоонараспространяется неотимениеёпервоначаль-
ногоавтора.
•Вовведенииилинатитульнойстраницедолжнобытьуказанопервичноеавторство
вформессылкинастраницу http://www.swaroopch.com/notes/Python сяснымуказа-
ниемнато,чтоисходныйтексткнигиможетбытьнайденпоэтомуадресу.
•Всефрагментыпрограмм/сценарии,представленныевэтойкниге,распространяют-
сянаусловияхМодифицированнойлицензииBSD5,еслиявнонеуказанообратное.
1.4
Читать
Выможете приступитькчтению книгивбраузерепрямосейчас.
(запаснаяссылка )
53-clauseBSDlicense (прим.перев. )
1.3. Лицензия 5A Byte of Python (Russian), Версия 2.02
1.5
Купить книгу
Чтобы иметь возможность почитать эту книгу без подключения к Интернету, а также
поддержатьеёдальнейшуюразработкуиусовершенствование,выможете купитьеёпе-
чатныйвариант (наанглийскомязыке).
1.6
Скачать
•ВвидеPDF-файла (самаясвежаяверсия)
запаснаяссылка
•ВформатеEPUB (безручногоформатирования).
запаснаяссылка
•Полныйисходник
Если вы хотите поддержать продолжение разработки этой книги, купитееёпечатную
копию .
1.7
Книга на вашем родном языке
Есливыхотитепочитатьэтукнигуилипомочьперевестиеёнадругиеязыки,перейдите
настраницу Переводы.
1.5. Купить книгу 6Переводы
Благодарямногимнеутомимымдобровольцам,Существуетмногопереводовэтойкниги
наразныеестественныеязыки.
Если вы хотите помочь с переводом, просмотрите список волонтёров для соответствую-
щихязыковвнизуирешите,стоитливамначатьновыйпереводилипомочьужесуще-
ствующемупроекту.
Есливырешилиначатьновыйперевод,прочитайте,пожалуйста, инструкцию по переводу .
2.1
Доступные переводыпереводы
2.1.1
Арабский
Ниже приведена ссылка на арабскую версию. Благодарность Ashraf Ali Khalaf за
перевод книги. Вы можете прочитать всю книгу в Интернете по этому адресу
<http://www.khaledhosny.org/byte-of-python/index.html> или скачать её с sourceforge.net . По-
дробнеесм. здесь.
2.1.2
Бразильский португальский
Существуетдваперевода:
SamuelDiasNeto (samuel.arataca-at-gmail-dot-com)осуществилпервыйперевод
этойкнигинабразильскийпортугальскийдляверсииPython2.3.5.
ПереводSamuel’ядоступеннастранице aprendendopython .
RodrigoAmaral (rodrigoamaral-at-gmail-dot-com)принялсязапереводкнигина
бразильскийпортугальский.
Перевод Rodrigo доступен на странице http://www.swaroopch.org/notes/
Python_pt-br:Indice .
7A Byte of Python (Russian), Версия 2.02
2.1.3
Каталонский
Moises Gomez (moisesgomezgiron-at-gmail-dot-com) приступил к переводу книги на ката-
лонскийязык.Переводнаходитсявпроцессе,ибылдоступеннастраницах erstwhilewiki .
Moisès Gómez :
«Я разработчик и преподаватель программирования (обычно для людей без
предварительнойподготовки).
НекотороевремяназадмнепонадобилосьизучитьPython,икнигаSwaroop’а
оченьпомогламне.Просто,понятноидостаточнополно.Какразто,чтомне
былонужно.
Послеэтогояподумал,чтотакаякнигаможетпригодитьсяидругимлюдямв
моейстране.Ноанглийскийязыкможетстатьпреградойдлянекоторых.
Так почему бы мне не перевести её? И я сделал это для предыдущей версии
книги.
Вмоейстранедвагосударственныхязыка.Явыбралкаталонский,таккакпо-
думал,чтонаболеераспространённыйиспанскийеёнавернякапереведёткто-
нибудьдругой.»
2.1.4
Китайский
Китайскую версию можно найти на http://www.swaroopch.org/notes/Python_cn:Table_of_
Contents.
Juan Shen (orion-underscore-val-at-163-dot-com)приступилкпереводукнигинакитайский
язык.
Она доступна по адресу http://www.pycn.org/python%E5%9C%A8%E7%BA%BF%E6%89%8B%
E5%86%8C .
«ЯаспирантотделабеспроводныхтелекоммуникацийвПекинскомтехноло-
гическом университете, Китай. В настоящее время я занимаюсь исследова-
нием синхронизации, регулировки канала передачи данных и многопользо-
вательским определением системы с многими несущими частотами CDMA.
Python является моим основным языком программирования для ежедневно-
го моделирования и расчётов. По большей части, с использованием Python
Numeric. Я познакомился с Python всего пол года назад, но как вы могли ви-
деть,этодействительнооченьлёгкийдляпониманияиосвоенияязык,ивме-
сте с тем, очень эффективный. Как и предупреждал в своей книге Swaroop,
«Теперьэтомойлюбимыйязыкпрограммирования».
«A Byte of Python» был моим учебником по Python. Он просто и эффектив-
но вводит вас в мир Python в кратчайшие сроки. Он не слишком длинный,
но покрывает практически все важные темы о Python. Я считаю, «A Byte of
2.1. Доступные переводыпереводы 8A Byte of Python (Russian), Версия 2.02
Python»нужновсегдарекомендоватьновичкамвкачествепервогоучебника.
Я посвящаю свой перевод миллионам потенциальных пользователей Python
вКитае.»
2.1.5
Традиционный китайский
Fred Lin(gasolin-at-gmail-dot-com)приступилкпереводукнигинатрадиционныйкитай-
скийязык.
Онадоступнапоадресу http://code.google.com/p/zhpy/wiki/ByteOfZhpy .
Любопытнойособенностьюэтогопереводаявляетсято,чтоонсодержитисходныетексты
накитайском Python нарядусоригинальнымитекстаминаPython.
Fred Lin:
«ЯработаюинженеромпрограммногообеспечениясетевыхустройстввDelta
Network.Крометого,яучастникразработкивеб-инструментарияTurboGears.
Как евангелист Python (:-p) я нуждаюсь в некотором материале, опираясь на
который я смогу популяризовать язык Python. Я обнаружил, что «A Byte of
Python» нашёл золотую середину между книгами для новичков и для опыт-
ных программистов. «A Byte of Python» подробно излагает основы Python в
разумныхобъёмах.
Мой перевод поначалу основывался на версии на упрощённом китайском
языке, но со временем в него было внесено множество изменений для под-
держанияеговсоответствиистекущимиверсиямикниги.
Последние версии перевода на традиционный китайский также отличаются
наличиемисходныхкодовпрограммнакитайскомPython,благодаряпроекту
«zhpy»,существующемусавгуста2007года.
zhpy(произноситсякак«Зэд.Аш.Пи»или«зиппи»)являетсяэдакойнадстрой-
койнадPython,переводящейPythonнатрадиционныйилиупрощённыйки-
тайский.Этотпроектсуществует,преждевсего,вобразовательныхцелях.
2.1.6
Французский
Gregory(coulix-at-ozforces-dot-com-dot-au)началпереводкнигинафранцузскийязык.
Gérard Labadie (Palmipede) закончил перевод книги. Она доступна на http://www.
swaroopch.org/notes/Python_fr:Table_des_Mati%C3%A8res .
2.1. Доступные переводыпереводы 9A Byte of Python (Russian), Версия 2.02
2.1.7
Немецкий
Lutz Horn (lutz-dot-horn-at-gmx-dot-de), Bernd Hengelein (bernd-dot-hengelein-at-gmail-dot-
com)и Christoph Zwerschke (cito-at-online-dot-de)началипереводнанемецкийязык.
Ихпереводнаходитсяна http://abop-german.berlios.de .
Lutz Horn говорит:
«Мне 32 года, я закончил математический факультет Гейдельбергского уни-
верситета в Германии. В настоящее время я работаю программистом в обще-
ственномпроектепосозданиювеб-порталакомпьютерныхнауквГермании.
Основной язык, который я использую на работе, – Java, но «за кулисами» я
стараюсь делать как можно больше на Python. Особенно легко удаётся про-
изводить анализ текста и конвертацию на Python. Я не очень знаком с ин-
струментариямидляграфическогоинтерфейса,таккакпобольшейчастиза-
нимаюсьвеб-программированием,гдеинтерфейспользователяформируется
такимиJava-инструментамикакStruts.Внастоящеевремяястараюсьбольше
применять функциональное программирование и генераторы. После корот-
кого взгляда на Ruby я был впечатлён использованием блоков в этом языке.
Мнетакженравитсядинамическаяприродатакихязыков,какPythonиRuby,
посколькуэтодаётмневозможностьделатьто,чтоневозможносделатьвбо-
леестатическихязыках,какJava.Ясталискатькакой-нибудьвводныйкурсв
программирование,подходящийдляполногоне-программиста.Янашёлкни-
ги «How to Think Like a Computer Scientist: Learning with Python» и «Dive into
Python». Первая книга хороша для новичков, но слишком длинна для пере-
вода. Вторая не подходит для новичков. А вот «A Byte of Python», как мне
кажется, попадает как раз между этими двумя, так как не слишком длинна,
написана по существу, но вместе с тем, достаточно подробна для обучения
новичка. Помимо этого, мне понравилась простая структура DocBook, кото-
раяпозволяетпереводитьтекст,атакжегенерироватьрезультирующийтекст
вразличныхформатахкакповолшебству.»
Bernd Hengelein говорит:
«Мы с Лутцем собираемся переводить книгу на немецкий язык вместе. Мы
начали с Введения и Предисловия, но мы будем информировать вас по мере
продвижения.
Теперь пару слов о себе. Мне 34 года, и я играюсь с компьютерами с 1980-х,
когда«CommodoreC64»повелевалдетскимикомнатами.Послетого,какяпо-
лучилобразованиевобластикомпьютерныхнаук,яначалработатьпрограм-
мистом. В настоящее время я работаю в области медицинской визуализации
в одной из крупнейших немецких компаний. И хотя основным языком, ко-
торым я (вынужденно) пользуюсь на работе, является C++, я постоянно ищу
новые пространства для освоения. В прошлом году я влюбился в чудесный
языкPythonодновременнозаеговозможностиикрасоту.Где-товИнтернете
2.1. Доступные переводыпереводы 10A Byte of Python (Russian), Версия 2.02
ячиталочеловеке,которыйсказал,чтоемунравитсяPython,потомучтопро-
граммынанёмвыглядяткрасиво.Намойвзгляд,онсовершенноправ.Когдая
начинализучатьPython,язаметил,чтохорошейдокументациинанемецком
языке по нему было очень мало. Когда же я наткнулся на вашу книгу, мне
в голову пришла внезапная идея перевести её на немецкий. К счастью, ана-
логичная идея пришла в голову и Лутцу, благодаря чему теперь мы можем
разделитьработу.Снетерпениемждупродуктивногосотрудничества!»
2.1.8
Греческий
Греческое сообщество Ubuntu перевело книгу на греческий язык , для использования
в уроках Python на своём форуме. Для более подробной информации свяжитесь с
@savvasradevic .
2.1.9
Индонезийский
Daniel(daniel-dot-mirror-at-gmail-dot-com) переводит книгу на индонезийский язык на
http://python.or.id/moin.cgi/ByteofPython .
W. Priyambodo такжеизъявилжеланиеперевестикнигунаиндонезийский.Переводна-
ходитсявпроцессенастранице http://www.swaroopch.org/notes/Python_id:Daftar_Isi .
2.1.10
Итальянский
Enrico Morelli (mr-dot-mlucci-at-gmail-dot-com) и Massimo Lucci (morelli-at-cerm-dot-unifi-
dot-it)взялисьзапереводкнигинаитальянскийязык.
Итальянскийпереводрасположеннаwww.gentoo.it/Programmazione/byteofpython.Новый
переводнаходитсявпроцессездесь: http://www.swaroopch.org/notes/Python_it:Prefazione .
Massimo Lucci иEnrico Morelli :
«Мы работаем в университете Флоренции (Италия) – на факультете хи-
мии. Я (Massimo) в качестве инженера и системного администратора ЯМР-
спектрометров,аEnrico–вкачествеинженераисистемногоадминистратора
параллельных/кластерныхсистем.МыпрограммируемнаPythonужеоколо
семи лет, а на платформах Linux мы работаем уже около десяти лет. Мы ад-
министрируем веб-страницу www.gentoo.it для дистрибутива Gentoo/Linux, а
также страницу www.nmr.it (в данный момент в разработке) о приложениях
ииспользованииядерногомагнитногорезонанса.Вотивсё!Нанаспроизвёл
впечатлениетотживойязык,которымнаписанаэтакнига,имысчитаем,что
этооченьважнодляпредставленияPythonновымпользователям(например,
сотнямстудентовиисследователейизнашихлабораторий).»
2.1. Доступные переводыпереводы 11A Byte of Python (Russian), Версия 2.02
2.1.11
Японский
Японскаяверсиядоступнана http://www.swaroopch.org/notes/Python_ja:Table_of_Contents
.
Shunro Dozono (dozono-at-gmail-dot-com)переводиткнигунаяпонскийязык.
2.1.12
Монгольский
Ariunsanaa Tunjin (luftballons2010-at-gmail-dot-com) принялся за перевод книги на мон-
гольскийязык.
Обновление от 22 ноября 2009г :Ariunsanaa награнизавершенияперевода.
2.1.13
Норвежский (bokmål)
Eirik Vågeskar (http://www.swaroopch.org/notes/User:Vages )–студент Sandvikavideregående
skoleв Норвегии, блоггер, и в данный момент переводит книгу на норвежский язык
(bokmål). Перевод находится в процессе. Вы можете взглянуть на него здесь: http://www.
swaroopch.org/notes/Python_nb-no:Innholdsfortegnelse .
Eirik Vågeskar :
«Я всегда хотел программировать, но поскольку я разговариваю на малорас-
пространённомязыке,процессобучениябылвсегдазатруднён.Большинство
пособий и книг написано на техническом английском языке, так что боль-
шинствовыпускниковшколыдаженеобладаютдостаточнымсловарнымза-
пасом, чтобы понять, о чём идёт речь. Но как только я нашёл эту книгу, мои
проблемы сразу разрешились. «A Byte of Python» простым нетехническим
языком объясняет язык программирования, который так же прост, и это де-
лает изучение Python увлекательным. После прочтения половины книги, я
понял, что её стоит перевести. Я надеюсь, что перевод поможет людям, ока-
завшимсявпохожейситуации(особенно,молодым),аможетбытьдажеивы-
зоветинтерескязыкусредилюдейсменьшимитехническимизнаниями.»
2.1.14
Польский
Dominik Kozaczko (dkozaczko-at-gmail-dot-com)приступилкпереводукнигинапольский.
Переводнаходитсявпроцессе,иегоглавнаястраницарасположеназдесь: UkąśPythona .
Обновление :Посостояниюна2октября2009г.переводзавершён.БлагодарностиДомини-
ку,двумегостудентамиихдругузапотраченноевремяиусилия!
Dominik Kozaczko: «Я преподаватель компьютерных наук и информационных техноло-
гий.»
2.1. Доступные переводыпереводы 12A Byte of Python (Russian), Версия 2.02
2.1.15
Португальский
Fidel Viegas (fidel-dot-viegas-at-gmail-dot-com) взялся за перевод книги на португальский
язык.
2.1.16
Румынский
Paul-Sebastian Manole (brokenthorn-at-gmail-dot-com)началпереводкнигинарумынский
язык.
Paul-Sebastian Manole :
«ЯстудентвторогокурсафакультетакомпьютерныхнауквуниверситетеSpiru
Haret University, в Румынии. Хотя, я больше программист-самоучка и решил
изучить новый язык – Python. Из Интернета я узнал, что нет лучшего пути
для этого, чем книга «A Byte of Python». Вот насколько популярна эта кни-
га (поздравляю её автора с тем, что ему удалось написать такую лёгкую для
восприятия книгу). Мне начал нравиться Python, и я решил помочь перево-
дом последней версии книги Swaroop’а на румынский язык. И хотя я и могу
оказатьсяпервымстакойинициативой,еслиувасестьжеланиепомочьмне,
присоединяйтесь.»
Переводпроизводитсяна http://www.swaroopch.org/notes/Python_ro .
2.1.17
Русский
Владимир Смоляр (v_2e-at-ukr-dot-net)перевёлкнигунарусскийязык.Текущуюверсию
переводаможнонайтина http://wombat.org.ua/AByteOfPython .
2.1.18
Украинский
Averkiev Andrey (averkiyev-at-ukr-dot-net) взялся за перевод книги на украинский язык
(насколькопозволяетвремя).
2.1.19
Словацкий
Albertio Ward (albertioward-at-gmail-dot-com) перевёл книгу на словацкий язык на
fatcow.com/edu/python-swaroopch-sl/:
«Мыявляемсянекоммерческойорганизациейподназванием«Переводыдля
обучения».Мыпредставляемсобойгруппулюдей,преимущественно,студен-
товипреподавателейСлавянскогоуниверситета.Срединасестьстудентыраз-
ныхфакультетов:лингвистики,химии,биологииит.д.Мыстараемсяотыски-
2.1. Доступные переводыпереводы 13A Byte of Python (Russian), Версия 2.02
ватьвИнтернетеинтересныепубликации,полезныедлянасилинашихкол-
лег.Иногдамысаминаходимстатьи,аиногданашипреподавателипомогают
намподобратьматериалдляперевода.Послеполученияразрешенияавторов
статьи мы переводим статьи и публикуем их в нашем блоге, доступном на-
шим коллегам и друзьям. Такие переводы часто бывают полезны студентам
приобучении.
Почему я выбрал именно вашу книгу для перевода? Я сделал это для того,
чтобыпомочьболгарампонятькнигувдеталях.Оценивновизнуиважность
обсуждаемых в книге тем, я понял, что она весьма актуальна для населения
моейстраны.Поэтомуядумаю,онабудетпопулярна.Ивданномслучаебудет
отсутствоватьязыковойбарьер,таккаконустранёнмоимпереводом.»
2.1.20
Испанский
Alfonso de la Guarda Reyes (alfonsodg-at-ictechperu-dot-net), Gustavo Echeverria (gustavo-
dot-echeverria-at-gmail-dot-com), David Crespo Arroyo (davidcrespoarroyo-at-hotmail-dot-
com) и Cristian Bermudez Serna (crisbermud-at-hotmail-dot-com) приступили к переводу
книги на испанский язык. Перевод находится в процессе. Вы можете читать испанский
(аргентинский) перевод на странице http://www.swaroopch.org/notes/Python_es-ar:Tabla_
de_Contenidos .
Gustavo Echeverria говорит:
«ЯработаюпрограммистомвАргентине.Побольшейчастияиспользуютех-
нологии C# и .NET на работе, но для моих собственных проектов – только
Python и Ruby. Я узнал о Python довольно давно, и сразу же остановился на
нём. Вскоре после моего знакомства с Python я обнаружил эту книгу, и она
помогла мне в изучении этого языка. Тогда я решил перевести её на испан-
ский язык. Теперь, после нескольких обращений я начал переводить «A Byte
ofPython»вместесMaximilianoSoler.»
Cristian Bermudez Serna говорит:
«Я студент факультета телекоммуникаций в университете Antioquia (Колум-
бия).НесколькомесяцевназадярешилизучатьPythonиобнаружилэтузаме-
чательнуюкнигу,послечегорешилподключитьсякеёпереводунаиспанский
язык.»
2.1. Доступные переводыпереводы 14A Byte of Python (Russian), Версия 2.02
2.1.21
Шведский
Mikael Jacobsson (leochingkwake-at-gmail-dot-com) решил перевести эту книгу на швед-
скийязык.
2.1.22
Турецкий
Türker SEZER (tsezer-at-btturk-dot-net) и Bugra Cakir (bugracakir-at-gmail-dot-com) начали
переводкнигинатурецкийязык.Гдетурецкаяверсия?Bitsedeokusak.
Примечание: Замените -at-на@,-dot-на.и-underscore- на_в адресах элек-
тронной почты, указанных на этой странице. Дефисы во всех остальных местах адреса
оставьтекакесть.
2.1. Доступные переводыпереводы 15Предисловие
Python–это,пожалуй,одинизнемногихязыковпрограммирования,простыхвосвоении
и одновременно мощных. Это очень важно и для начинающих, и для специалистов, но
чтоещёважнее–нанёмприятнопрограммировать.Настоящаякнигапризванапомочь
вамвизученииэтогозамечательногоязыкаипоказать,какможнобыстроибезболезнен-
ноделатьмногиевещи–всущности,этотакоесебе«Идеальноепротивоядиепротиввсех
вашихпроблемвпрограммировании».
3.1
Для кого эта книга
Этакнигаслужитпутеводителемилиучебнымпособиемдляизученияязыкапрограмми-
рования Python. Она нацелена, преимущественно, на новичков. Темне менее, она будет
полезнаиопытнымпрограммистам.
Автор задумал эту книгу так, чтобы изучить Python по ней смог любой, кто умеет хотя
бысохранятьтекстовыефайлы,впрочем,иопытпрограммированияэтомунепомеха.
Еслиувастакиимеетсяпредварительныйопытпрограммирования,васнаверняказаин-
тересуют различия между Python и вашим любимым языком программирования, мно-
гиеизкоторыхспециальновыделенывтексте.Однако,считаюсвоимдолгомпредупре-
дитьвасотом,чтовскоревашимлюбимымязыкомпрограммированиявсёравностанет
Python!
3.2
Немного истории
Впервые я обратился к Python, когда мне понадобилось написать установщик для сво-
ейпрограммы«Diamond»,чтобыупроститьпроцессустановки.Мнепришлосьвыбирать
между привязками Python и Perl к библиотеке Qt. Я поискал информацию в сети на эту
тему и наткнулся на статью Эрика С. Реймонда , известного и уважаемого хакера, в ко-
торой он рассказывает о том, как Python стал его любимым языком программирования.
Также я выяснил, что привязки PyQt были более зрелыми по сравнению с Perl-Qt. Так я
определилсясвыборомвпользуPython.
16A Byte of Python (Russian), Версия 2.02
После этого я начал искать хорошую книгу по Python. И не нашёл! Конечно, я нашёл
несколькокнигO’Reilly,ноонибылилибослишкомдорогими,либобольшепоходилина
справочник, нежели на учебник. Так что мне пришлось довольствоваться документаци-
ей, поставляемой в комплекте с Python. Но она оказалась слишком краткой и неполной.
Безусловно,онадаламненекотороепредставлениеотом,чтотакоеPython,ноэтогобыло
явно недостаточно. Мне её хватало, поскольку я имел предыдущий опыт программиро-
вания,ноонаникоимобразомнеподходиладляновичков.
ПримерночерезполгодапослемоихпервыхшаговвPythonяустановилпоследнюю(на
тотмомент)версиюRedHatLinux9.0иначалигратьсясKWord.Ябылввосторгеотнего,
ивдругмнепришловголовунаписатьвнёмнекоторыемыслиоPython.Ярассчитывал
написатьнесколькостраниц,нообъёмбыстровыросдо30страниц.Тогдаярешилвсерьёз
придатьэтомутекстуформукниги.После множества переписыванийонадостиглатого
состояния, в котором она уже могла служить полезным пособием по изучению языка
Python.ЯсмотрюнасвоюкнигукакнасвойвкладиданьсообществусвободногоПО.
Эта книга была начата как мои личные заметки о Python, и я до сих пор смотрю на неё
также,хотяиприложилнемалоусилийктому,чтобысделатьеёболееподходящейдля
других:)
И конечно, в духе свободного ПО, я получил множество конструктивных предложений,
критикииотзывовотчитателей,которыепомоглимнезначительноулучшитькнигу.
3.3
Состояние книги
Воктябре2012годабыливнесенынекоторыеисправления,обновления,атакжепопрось-
бам нескольких пользователей страницы этой книги были переформатированы при по-
мощи Pandoc для того, чтобы сделать возможным автоматическое генерирование элек-
тронныхкнигнаихоснове.
Вредакциизадекабрь2008года(посравнениюспредыдущимсерьёзнымпересмотромв
марте2005года)былидобавленысведения,связанныесвыходомPython3.0.
Эта книга нуждается в помощи своих читателей по обнаружению не очень хорошо, не
очень понятно или попросту неверно написанных частей. Если у вас есть такие предло-
жения,пожалуйста,обращайтесь ксамомуавторукниги или к автору перевода ,который
вычитаете.
3.3. Состояние книги 17A Byte of Python (Russian), Версия 2.02
3.4
Официальная веб-страница
Официальнаястраницаэтойкнигинаходитсяпоадресу https://python.swaroopch.com ,где
выможетепрочитатьсамукнигу,скачатьеёпоследнююверсию, купитьеёпечатныйва-
риантиоставитьсвоиотзывы.
3.5
К размышлению
«Существуетдваспособасоставленияпрограмм:первыйсостоитвтом,чтобы
сделать её настолько простой, чтобы в ней явно не было ошибок; второй – в
том, чтобы сделать её настолько сложной, чтобы в ней не было явных оши-
бок.»
–C.A.R.Hoare
«Успехвжизни–нестольковопросталантаивозможностей,сколькоконцен-
трацииинастойчивости.»
–C.W.Wendte
3.4. Официальная веб-страница 18Введение
Python–одинизтехредкихязыковпрограммирования,которыеодновременнопретен-
дуют на звание простыхимощных. Вас приятно удивит то, как легко можно сосредото-
читьсянарешениипоставленнойзадачи,аненасинтаксисеиструктуреязыка,накото-
ромвыпрограммируете.
ОфициальноPythonпредставляюттак:
Python – это простой в освоении и мощный язык программирования. Он
предоставляет эффективные высокоуровневые структуры данных, а также
простой,ноэффективныйподходкобъектно-ориентированномупрограмми-
рованию.Егоэлегантныйсинтаксисидинамическаятипизациянарядустем,
чтоонявляетсяинтерпретируемым,делаютегоидеальнымязыкомдлянапи-
сания сценариев и быстрой разработки приложений в различных областях и
набольшинствеплатформ.
Вследующемразделемырассмотримэтиособенностиболеедетально.
Историяназвания
Гвидо ван Россум, создатель языка Python, назвал его так в честь телешоу на
BBC под названием «Летающий цирк Монти Пайтона»1, а вовсе не потому,
что он любит змей, убивающих животных обвиванием своего длинного тела
вокругнихизадавливанием.
4.1
Особенности Python
4.1.1
Простой
Python–простойиминималистичныйязык.ЧтениехорошейпрограммынаPythonочень
напоминаетчтениеанглийскоготекста,хотяидостаточнострогого!Такаяпсевдо-кодовая
природа Python является одной из его самых сильных сторон. Она позволяет вам сосре-
доточитьсянарешениизадачи,аненасамомязыке.
1«MontyPython’sFlyingCircus»( прим.перев. )
19A Byte of Python (Russian), Версия 2.02
4.1.2
Лёгкий в освоении
Каквыувидите,наPythonчрезвычайнолегконачатьпрограммировать.Pythonобладает
исключительнопростымсинтаксисом,какужеотмечалосьвыше.
4.1.3
Свободный и открытый
Python – это пример свободного и открытого программного обеспечения – FLOSS
(Free/Libré and Open Source Software). Проще говоря, вы имеете право свободно распро-
странять копии этого программного обеспечения, читать его исходные тексты, вносить
изменения,атакжеиспользоватьегочастивсвоихпрограммах.ВосновесвободногоПО
лежит идея сообщества, которое делится своими знаниями. Это одна из причин, по ко-
торым Python так хорош: он был создан и постоянно улучшается сообществом, которое
простохочетсделатьеголучше.
4.1.4
Язык высокого уровня
ПринаписаниипрограммынаPythonвамникогданепридётсяотвлекатьсянатакиениз-
коуровневыедетали,какуправлениепамятью,используемойвашейпрограммой,ит.п.
4.1.5
Портируемый
Благодаря своей открытой природе, Python был портирован на много платформ (т.е. из-
менён таким образом, чтобы работать на них). Все ваши программы смогут запускаться
налюбойизэтихплатформбезкаких-либоизменений,еслитольковыизбегалиисполь-
зованиясистемно-зависимыхфункций.
Python можно использовать в GNU/Linux, Windows, FreeBSD, Macintosh, Solaris, OS/2,
Amiga,AROS,AS/400,BeOS,OS/390,z/OS,PalmOS,QNX,VMS,Psion,AcornRISCOS,VxWorks,
PlayStation,SharpZaurus,WindowsCEидаженаPocketPC!
Вы можете даже использовать такую платформу, как Kivyдля создания игр для iOS
(iPhone,iPad)иAndroid.
4.1.6
Интерпретируемый
Этотребуетнекоторогопояснения.
Программа, написанная на компилируемом языке программирования, как например, C
или C++, преобразуется из исходного языка (т.е. C или C++) в язык, понятный компью-
теру (бинарный код, т.е. нули и единицы) при помощи компилятора с применением
4.1. Особенности Python 20A Byte of Python (Russian), Версия 2.02
разнообразных флагов и параметров. Когда вы запускаете такую программу, компонов-
щик/загрузчиккопируетпрограммусдискавоперативнуюпамятьизапускаетеё.
Pythonже,напротив,нетребуеткомпиляциивбинарныйкод.Программапросто выполня-
етсяизисходноготекста.Pythonсампреобразуетэтотисходныйтекствнекоторуюпро-
межуточнуюформу,называемуюбайткодом,азатемпереводитегонамашинныйязыки
запускает. Всё это заметно облегчает использование Python, поскольку нет необходимо-
стизаботитьсяокомпиляциипрограммы,подключенииизагрузкенужныхбиблиотеки
т.д.Вместестем,этоделаетпрограммынаPythonнамногоболеепереносимыми,таккак
достаточноихпростоскопироватьнадругойкомпьютер,иониработают!
4.1.7
Объектно-ориентированный
Python поддерживает как процедурно-ориентированное, так и объектно-
ориентированноепрограммирование.В процедурно-ориентированных языкахпрограммы
строятсянаосновепроцедурилифункций,которыепредставляютсобойпросто-напросто
многократно используемые фрагменты программы. В объектно-ориентированных язы-
ках программирования программы строятся на основе объектов, объединяющих в себе
данные и функционал. Python предоставляет простые, но мощные средства для ООП,
особенно в сравнении с такими большими языками программирования, как C++ или
Java.
4.1.8
Расширяемый
Если вам нужно, чтобы некоторая критическая часть программы работала очень быстро
или вы вынуждены скрыть часть алгоритма, вы можете написать эту часть программы
наCилиC++,азатемвызыватьеёизпрограммынаPython.
4.1.9
Встраиваемый
PythonможновстраиватьвпрограммынаC/C++,чтобыпредоставлятьвозможностина-
писаниясценариевихпользователям.
4.1.10
Обширные библиотеки
Стандартная библиотека Python просто огромна. Она может помочь в решении самых
разнообразныхзадач,связанныхсиспользованиемрегулярныхвыражений,генерирова-
ниемдокументации,проверкойблоковкода,распараллеливаниемпроцессов,базамидан-
ных,веб-браузерами,CGI,FTP,электроннойпочтой,XML,XML-RPC,HTML,WAVфайла-
ми,криптографией,GUI(графическиминтерфейсомпользователя)идругимисистемно-
зависимыми вещами. Помните, что всё это доступно абсолютно везде, где установлен
Python.ВэтомзаключаетсяфилософияPython«Всёвключено».
4.1. Особенности Python 21A Byte of Python (Russian), Версия 2.02
Кроместандартнойбиблиотеки,существуетмножестводругихвысококачественныхбиб-
лиотек,которыеможнонайтив КаталогепакетовPython
Резюме
Python–оченьувлекательныйимощныйязык.Онимеетхорошеесоотноше-
ниепроизводительностиивозможностей,чтоделаетнаписаниепрограммна
нёмодновременноинтереснымилёгким.
4.2
Python 2 против 3
Если вас не интересует разница между Python 2 и Python 3, вы можете пропустить этот
радел.Новлюбомслучаепомните,какуюверсиювыиспользуете.
В 2008 году эта книга была переписана для Python 3. Это была одна из первых книг, по-
свящённыхPython3.Однако,ксожалению,этопривелокпутаницесредипользователей,
пытавшихся изучать Python 2 по версии книги для Python 3 и наоборот. Тем не менее,
мирпонемногумигрируетнаPython3.
Такчтода,вэтойкнигевыбудетеучитьсяпрограммироватьнаPython3,дажеесливко-
нечномсчётепланируетеиспользоватьPython2. Помните, что как только вы как следует
усвоите и научитесь пользоваться любым из них, вы также сможете легко освоить разницу
между ними и адаптироваться. Самое сложное заключается в обучении программированию
и понятии основной части языка Python. Это и будет нашей целью в настоящей книге, а
как только вы её достигнете, вы сможете запросто использовать Python 2 или Python 3 в
зависимости от конкретной ситуации.
Изучить разницу между Python 2 и Python 3 в деталях можно на странице Ubuntu wiki,
посвящённойPython3 .
4.3
Что говорят программисты
Интересно,чтотакиевеликиехакеры,какЭрикРэймонд,говорятоPython:
1.Эрик С. Рэймонд – автор работы «Собор и Базар», а также человек, который ввёл
термин«OpenSource».Онговорит,что Pythonсталеголюбимымязыкомпрограм-
мирования .ЭтастатьяивдохновиламенянапробуперавPython.
2.Брюс Экель – автор знаменитых книг «Думаем на Java» и «Думаем на С++». Он
утверждает, что ни на одном языке программирования его работа не была столь
эффективной, как на Python. Кроме того, он считает, что Python – это, пожалуй,
единственныйязык,стремящийсяоблегчитьжизньпрограммисту.Подробнеемож-
нопрочитатьв егополноминтервью .
4.2. Python 2 против 3 22A Byte of Python (Russian), Версия 2.02
3.Питер Норвиг – широко известный автор Lisp, а также директор по качеству поис-
ка в Google (спасибо Гвидо ван Россуму за это замечание). Он говорит, что Python
всегдабылнеотъемлемойчастьюGoogle.Выможетеубедитьсявэтом,заглянувна
страницу GoogleJobs ,накоторойвладениеPythonуказанокактребованиедляраз-
работчиковпрограммногообеспечения.
4.3. Что говорят программисты 23Установка
Если у вас уже установлен Python 2.x, нет необходимости его удалять для того, чтобы
установитьPython3.0.Обеверсиимогутбытьустановленывсистемеодновременно.
5.1
Установка в GNU/Linux и BSD
Если вы используете один из дистрибутивов GNU/Linux, таких как Ubuntu, Fedora,
OpenSUSE,Debian,CentOSили{вашвариант},илиодинизвариантовBSD,какнапример,
FreeBSD,тоскореевсего,ввашейсистемеужеустановленPython.
Чтобыпроверить,установленлиPythonнавашеймашинесBSDилиGNU/Linux,открой-
те эмулятор терминала (например, konsole или gnome-terminal ) и введите команду
python -V ,какпоказанониже.
$ python -V
Python 3.3.0
Примечание: $–этоприглашениекоманднойстроки.Ономожетвыглядетьпо-разному
в зависимости от настроек вашей ОС, поэтому я буду обозначать приглашение просто
однимсимволом $.
Есливывидитеинформациюоверсии,какпоказановыше,значитPythonувасужеуста-
новлен.
Еслижевыполучаететакоесообщение:
$ python -V
bash: Python: command not found
значит,Pythonуваснеустановлен.Этомаловероятно,новсёжевозможно.
Примечание: ЕслиувасужеустановленPython3.x,попробуйте python3 -V .
24A Byte of Python (Russian), Версия 2.02
ВэтомслучаеувасбудутдвавариантаустановкиPython:
•СкомпилироватьPythonиз исходныхтекстов иустановитьего.Инструкцияпоком-
пиляцииестьнауказанномвеб-сайте.
•Установить бинарные пакеты, используя пакетный менеджер, входящий в ком-
плектпоставкивашейОС,какнапример, apt-getвUbuntu/Debianидругихдистри-
бутивах, основанных на Debian, yumв Fedora, pkg_add во FreeBSD, и т.д. Обратите
внимание, что для этого потребуется соединение с Интернетом. В противном слу-
чаевыможетелюбымдругимспособомскопироватьбинарникинасвойкомпьютер
иустановитьоттуда.
5.2
Установка в Windows
Посетитестраницу http://www.python.org/download/ изагрузитепоследнююверсию.Уста-
новкапроизводитсятакже,какидлялюбыхдругихпрограммдляWindows.
Осторожно: Когда вам будет предложено отключить некоторые «опцио-
нальные»компоненты,неотключайтениодного!Некоторыеизэтихком-
понентовмогутвампригодиться,особенноIDLE.
Интересно, что большую часть загрузок производят именно пользователи Windows. Ко-
нечно,этонедаётпредставленияополнойкартине,посколькуубольшинствапользова-
телейGNU/LinuxPythonустановленвсистемепоумолчанию.
5.2.1
Командная строка DOS
Для использования Python из командной строки Windows, т.е. приглашения DOS, необ-
ходимоустановитьдолжнымобразомпеременнуюPATH.
Для Windows 2000, XP, 2003 , перейдите в «Панель управления» →«Система» →«До-
полнительно» →«Переменные среды». Нажмите на переменной с именем PATHв отде-
ле «Системные переменные», после этого выберите «Редактировать» и допишите ;C:\
Python33 кконцутого,чтотамужеесть(проверьте,существуетлитакойкаталог,таккак
для более новых версий Python он будет иметь другое имя). Конечно, укажите действи-
тельноеимякаталога.
ДляболеестарыхверсийWindowsдобавьтеследующуюстрокувфайл C:\AUTOEXEC.BAT
:„PATH=%PATH%;C:\Python33 “(безкавычек)иперезапуститесистему.ДляWindowsNT
используйтефайл AUTOEXEC.NT .
ДляWindowsVista:
1.Нажмитекнопку«Пуск»ивыберите«Панельуправления».
5.2. Установка в Windows 25A Byte of Python (Russian), Версия 2.02
2.Нажмите «Система», справа вы увидите «Просмотр основных сведений о вашем
компьютере». Слева – список действий, последним из которых будет «Дополни-
тельныепараметрысистемы.»Нажмитееё.Отобразитсявкладка«Дополнительно»
диалогапараметровсистемы.Нажмитекнопку«Переменныесреды»справавнизу.
3.В нижнем поле под названием «Системные переменные» прокрутите до Pathи
нажмитекнопку«Редактировать».
4.Изменитепуть,какнужно.
5.Перезапуститесистему.Vistaнеобновляетсистемныепутидоперезагрузки.
ДляWindows7:
1.Щёлкните правой кнопкой мыши на значке «Компьютер» на рабочем столе и вы-
берите«Свойства»;иначе–нажмитекнопку«Пуск»ивыберите«ПанельУправле-
ния»→«Системаибезопасность» →«Система».Нажмите«Дополнительныепара-
метрысистемы»слева,азатемвыберитевкладку«Дополнительно».Внизунажмите
кнопку «Переменные среды» и в отделе «Системные переменные» найдите пере-
менную PATH,выберитееёинажмите«Редактировать».
2.Перейдите к концу строки в поле «Значение переменной» и допишите ;C:\
Python33 .
3.Если значение переменной было %SystemRoot%\system32; , теперь оно примет
вид%SystemRoot%\system32;C:\Python33
4.Нажмите«Ok»,ивсё.Перезагрузканетребуется.
5.2.2
Запуск командной строки Python в Windows
Если вы должным образом установили значение переменной PATH , теперь можно запус-
катьинтерпретаторизкоманднойстроки.
ЧтобыоткрытьтерминалвWindows,нажмитекнопку«Пуск»ивыберите«Выполнить».
Впоявившемсядиалоговомокненаберите cmdинажмите Enter.
Затемнаберите pythonипроверьте,нетлиошибок.
5.3
Для пользователей Mac OS X
УпользователейMacOSXPythonужебудетустановленвсистеме.Впротивномслучаевы
можетеоткрытьтерминал,нажав Command+Пробел ,набраввоткрывшейсястрокепоиска
Terminal инажав Enter.
Затемустановить Homebrew ,выполнив:
5.3. Для пользователей Mac OS X 26A Byte of Python (Russian), Версия 2.02
ruby -e"$(curl -fsSkL raw.github.com/mxcl/homebrew/go) "
ПослечегоустановитьPython3припомощи:
brew install python3
Атеперьзапустите python3 -V ипроверьте,нетлиошибок.
5.4
Резюме
УпользователейсистемGNU/LinuxиBSD,вероятнеевсего,Pythonужеустановлен.Впро-
тивном случае его можно установить, используя пакетный менеджер, поставляемый с
вашимдистрибутивом.ДляWindowsустановкаPythonсводитсякзагрузкеустановщика
и двойному щелчку на нём. С этого момента мы будем считать, что Python 3 в вашей
системеустановлен.
ДалеемыприступимкнаписаниюнашейпервойпрограммынаPython.
5.4. Резюме 27Первые шаги
Давайтепосмотрим,каксоздатьтрадиционнуюпрограмму«HelloWorld»наPython.Это
научитвасписать,сохранятьивыполнятьпрограммынаPython.
Существует два способа запуска программ на Python: использование интерактивного
приглашения интерпретатора и использование файла с текстом программы. Сейчас мы
увидим,какпользоватьсяобоимиметодами.
6.1
Использование командной строки интерпрета-
тора
Откройтеокнотерминала(какбылоописановглаве Установка )изапуститеинтерпрета-
торPython,введякоманду python3инажав Enter.
Пользователи Windows могут запустить интерпретатор в командной строке, если уста-
новили переменную PATHнадлежащим образом. Чтобы открыть командную строку в
Windows, зайдите в меню «Пуск» и нажмите «Выполнить…». В появившемся диалого-
вомокневведите«cmd»инажмите Enter;теперьувасбудетвсёнеобходимоедляначала
работысpythonвкоманднойстрокеDOS.
Если вы используете IDLE, нажмите «Пуск» →«Программы» →«Python 3.0» →«IDLE
(PythonGUI)».
Кактольковызапустили python3,выдолжныувидеть >>>вначалестроки,гдевыможете
что-тонабирать.Этоиназывается командной строкой интерпретатора Python .
Теперьвведите print('Hello World') инажмитеклавишу Enter.Врезультатедолжны
появитьсяслова«HelloWorld».
Вотпримертого,чтовыможетеувидетьнаэкране,еслибудетеиспользоватькомпьютерс
MacOSX.ИнформацияоверсииPythonможетотличатьсявзависимостиоткомпьютера,
ночасть,начинающаясясприглашения(т.е.от >>>идалее)должнабытьодинаковойна
всехоперационныхсистемах.
28A Byte of Python (Russian), Версия 2.02
$ python3
Python 3.3.0 (default, Oct 22 2012, 12:20:36)
[GCC 4.2.1 Compatible Apple Clang 4.0 ((tags/Apple/clang-421.0.60))] on darwin
Type "help", "copyright", "credits" or "license" for more information.
>>> print('hello world')
hello world
>>>
Обратитевнимание,чтоPythonвыдаётрезультатработыстрокинемедленно!Вытолько
чтоввелиодиночный«оператор»Python. printиспользуетсядлятого,чтобы(чтонеуди-
вительно1)напечататьлюбоепереданноевнегозначение.Вданномслучаемыпередали
внеготекст«HelloWorld»,которыйибылнапечатаннаэкране.
Совет:Каквыйтиизкоманднойстрокиинтерпретатора
ЕсливыиспользуетеIDLEилиоболочкуGNU/LinuxилиBSD,выможетевыйтиизкоманд-
ной строки интерпретатора нажатием Ctrl-Dили введя команду exit()(примечание:
не забудьте написать скобки, «()»), а затем нажав клавишу Enter. Если вы используете
команднуюстрокуWindows,нажмите Ctrl-Z,азатемнажмитеклавишу Enter.
6.2
Выбор редактора
Поскольку мы не можем набирать программу в командной строке интерпретатора каж-
дый раз, когда нам нужно что-то запустить, нам понадобится сохранять программы в
файлах,чтобыпотомиметьвозможностьзапускатьихсколькоугоднораз.
ПреждечемприступитькнаписаниюпрограммнаPythonвфайлах,намнуженредактор
дляработысфайламипрограмм.Выборредакторакрайневажен.Подходитьквыборуре-
дактораследуеттакже,какиквыборуличногоавтомобиля.Хорошийредакторпоможет
вам легко писать программы на Python, делая ваше путешествие более комфортным, а
такжепозволяябыстрееибезопаснеедостичьвашейцели.
Одноизсамыхосновныхтребований–это подсветка синтаксиса ,когдаразныеэлементы
программынаPythonраскрашенытак,чтобывымоглилегко видетьвашупрограммуи
ходеёвыполнения.
Если вы не знаете, с чего начать, я бы порекомендовал воспользоваться программой
KomodoEdit ,котораядоступнадляWindows,MacOSXиGNU/Linux.
Если вы пользуетесь Windows, Не используйте Блокнот – это плохой выбор, посколь-
ку он не обладает функцией подсветки синтаксиса, а также не позволяет автоматически
1«print»– англ.«Печатать»( прим. перев. )
6.2. Выбор редактора 29A Byte of Python (Russian), Версия 2.02
вставлятьотступы,чтооченьважновнашемслучае,какмыувидимпозже.Хорошиере-
дакторы,какKomodoEdit,позволяютделатьэтоавтоматически.
Опытные программисты, должно быть, уже используют VimилиEmacs. Не стоит даже
и говорить, что это два наиболее мощных редактора, и вы только выиграете от их ис-
пользования для написания программ на Python. Лично я пользуюсь ими обоими для
большинствасвоихпрограмм,идаженаписал книгуоVim .Янастоятельнорекомендую
вамрешитьсяипотратитьвремянаизучениеVimилиEmacs,посколькуэтобудетприно-
ситьвампользудолгиегоды.Однако,какяужеписалвыше,новичкимогутпокапросто
остановиться на Komodo Edit и сосредоточиться на изучении Python, а не текстового ре-
дактора.
Яповторюсьещёраз:обязательновыберитеподходящийредактор–этосделаетнаписа-
ниепрограммнаPythonболеепростымизанимательным.
ДляпользователейVim
Существует хорошее введение в использование Vim как мощного IDE для
Python, автор – John M Anderson . Также я рекомендую плагин jedi-vim имой
собственныйконфигурационныйфайл .
ДляпользователейEmacs
Существует хорошее введение в использование Emacs как мощного IDE для
Python, автор – Ryan McGuire . Также я рекомендую Конфигурацию dotemacs
отBG.
6.3
Использование программных файлов
Атеперьдавайтевернёмсякпрограммированию.Существуеттакаятрадиция,чтокакой
бы язык программирования вы ни начинали учить, первой вашей программой должна
бытьпрограмма«Привет,Мир!».Этопрограмма,котораяпростовыводитнадпись«При-
вет, Мир!». Как сказал Simon Cozens2, это «традиционное заклинание богов программи-
рования,котороепоможетвамлучшеизучитьязык».
Запуститевыбранныйвамиредактор,введитеследующуюпрограммуисохранитееёпод
именем helloworld.py .
Если вы пользуетесь Komodo Edit, нажмите «Файл» →«Новый» →«Новый файл», вве-
дитестроку:
print ('Привет, Мир! ')
ВKomodoEditнажмите«Файл» →«Сохранить»длясохраненияфайла.
2Авторвосхитительнойкниги«BeginningPerl»
6.3. Использование программных файлов 30A Byte of Python (Russian), Версия 2.02
Кудасохранитьфайл?Влюбуюпапку,расположениекоторойвызнаете.Есливынепони-
маете,чтоэтозначит,тосоздайтеновуюпапкуииспользуйтееёдлявсехвашихпрограмм
наPython:
•C:\pyвWindows
•/tmp/pyвGNU/Linux
•/tmp/pyвMacOSX
Чтобысоздатьпапку,воспользуйтеськомандой mkdirвтерминале.Например, mkdir /
tmp/py.
Важно:Незабывайтеуказыватьрасширениефайла .py.Например,« file.py».
В Komodo Edit нажмите «Инструменты» →«Запуск команды», наберите python3
helloworld.py и нажмите «Выполнить». Вы должны увидеть вывод, показанный на
скриншотениже.
Новсё-такилучшередактироватьпрограммувKomodoEdit,азапускатьвтерминале:
1.Откройтетерминал,какописановглаве Установка .
2.Перейдитевкаталог,вкоторомвысохранилифайл.Например, cd /tmp/py .
3.Запуститепрограмму,введякоманду python3 helloworld.py .
Выводпрограммыпоказанниже.
$ python3 helloworld.py
Привет, Мир!
Если у вас получился такой же вывод, поздравляю! – вы успешно выполнили вашу
первуюпрограммунаPython.Вытолькочтосовершилисамыйсложныйшагвобучении
программированию,заключающийсявнаписаниисвоейпервойпрограммы!
Если вы получите сообщение об ошибке, введите вышеуказанную программу в точно-
ститак,какпоказаноздесь,изапуститеснова.Обратитевнимание,чтоPythonразличает
регистрбукв,тоесть print–этонетожесамое,что Print(обратитевниманиенабукву
pвнижнемрегистревпервомслучаеинабукву Pвверхнемрегистревовтором).Также
убедитесь,чтопередпервымсимволомвстрокенетпробеловилисимволовтабуляции–
позжемыувидим,почемуэтоважно.
Как это работает
ПрограмманаPythonсостоитиз выражений .Внашейпервойпрограммеиме-
етсявсеголишьодновыражение.Вэтомвыражениимывызываемфункцию
print,котораяпростовыводиттекст 'Привет, Мир!' .Офункцияхмыузна-
емв одной из последующих глав ,апокавамдостаточнопонять,чтовсё,чтовы
6.3. Использование программных файлов 31A Byte of Python (Russian), Версия 2.02
укажете в скобках, будет выведено на экран. В данном примере мы указали
'Привет, Мир!' .
6.3.1
Исполнимые программы на Python
Это касается только пользователей GNU/Linux и Unix, но пользователям Windows тоже
будетполезнообэтомзнать.
Каждый раз, когда нам нужно запустить программу на Python, нам приходится в явном
виде запускать python3 foo.py . Но почему бы нам не запускать её точно так же, как и
вседругиепрограммы?Этогоможнодостичьприпомощитакназываемого hashbang.
Добавьтестроку,указаннуюниже,в самое начало вашейпрограммы:
6.3. Использование программных файлов 32A Byte of Python (Russian), Версия 2.02
#!/usr/bin/env python3
Теперьвашапрограммадолжнавыглядетьтак:
#!/usr/bin/env python3
print ('Привет, Мир! ')
Теперь необходимо установить программе атрибут исполнимости, используя команду
chmod,азатем выполнить программу.
Команда chmodздесьиспользуетсядляизменениярежимафайла3добавлениематрибута
исполнимостидлявсехпользователейвсистеме4.
$ chmod a+x helloworld.py
Послеэтогомыможемзапускатьпрограммунапрямую,потомучтонашаоперационная
системазапустит /usr/bin/env ,который,всвоюочередь,найдётPython3,азначит,смо-
жетзапуститьнашфайл.
$ ./helloworld.py
Привет, Мир!
Здесь« ./»обозначает,чтопрограмманаходитсявтекущемкаталоге.
Радиинтересаможетедажепереименоватьфайлвпросто« helloworld »изапуститьего
как./helloworld , и это также сработает, поскольку система знает, что запускать про-
граммунужноинтерпретатором,положениекоторогоуказановпервойстрокефайлапро-
граммы.
Но до сих пор мы могли выполнять свою программу только если знали полный путь
к ней. А что, если нам нужно запускать эту программу из любого каталога? Это можно
организовать,расположивсвоюпрограммуводномизкаталогов,перечисленныхвпере-
меннойокружения PATH.
При попытке запуска какой-либо программы система ищет её в каталогах, перечислен-
ныхвпеременнойокружения PATH,изапускает.Такимобразом,мыможемсделатьпро-
граммудоступнойизлюбогоместа,скопировавеёводинизкаталогов,перечисленныхв
PATH.
$ echo $PATH
/usr/local/bin:/usr/bin:/bin:/usr/X11R6/bin:/home/swaroop/bin
$ cp helloworld.py /home/swaroop/bin/helloworld
$ helloworld
Привет, Мир!
3change mode–англ.«изменитьрежим»( прим. перев. )
4Вуказаннойкомандебуква« a»взятаизслова« all»(англ.«все»),абуква« x»–изслова«e xecute»( англ.
«исполнять»)– прим. перев.
6.3. Использование программных файлов 33A Byte of Python (Russian), Версия 2.02
Мы можем вывести на экран значение переменной PATHпри помощи команды echo,
добавивпередименемпеременнойсимвол $,чтобыуказатьоболочке,чтомыхотимпо-
лучить значение этой переменной. Мы видим, что /home/swaroop/bin – один из ка-
талогов в переменной PATH, где swaroop– это имя пользователя, которое я использую
в своей системе. В вашей системе, скорее всего, будет аналогичный каталог для вашего
пользователя.
Вытакжеможетедобавитькакой-либокаталогкпеременной PATH–этоможносделать,
выполнив PATH=$PATH:/home/swaroop/mydir , где '/home/swaroop/mydir' – это ка-
талог,которыйяхочудобавитькпеременной PATH.
Этотметодполезендлянаписаниясценариев,которыебудутдоступныдлязапускавлю-
боймоментизлюбогоместа.Посути,эторавносильносозданиюсобственныхкоманд,как
cdили любой другой, которые часто используются в терминале GNU/Linux или пригла-
шенииDOS.
Примечание: Когда речь идёт о Python, слова «программа» или «сценарий (скрипт)»
обозначаютодноитоже.
6.4
Получение помощи
Для быстрого получения информации о любой функции или операторе Python служит
встроенная функция help. Это особенно удобно при использовании командной строки
интерпретатора.Кпримеру,выполните help(print) –этопокажетсправкупофункции
print,котораяиспользуетсядлявыводанаэкран.
Примечание: Длявыходаизсправкинажмите q.
АналогичнымобразомможнополучитьинформациюпочтиочёмугодновPython.При
помощифункции help()можнодажеполучитьописаниесамойфункции help!
Если вас интересует информация об операторах, как например, return, их необходимо
указыватьвкавычках(например, help('return') ),чтобыPythonпонял,чегомыхотим.
6.4. Получение помощи 34A Byte of Python (Russian), Версия 2.02
6.5
Резюме
Теперьвыумеетеслёгкостьюписать,сохранятьизапускатьпрограммынаPython.
И поскольку сейчас вы уже используете Python, давайте узнаем больше о его основных
принципах.
6.5. Резюме 35Основы
Простонапечатать«Привет,Мир!»недостаточно,верно?Выхотитесделатьбольше–вы
хотите ввести что-то в программу, обработать и получить нечто на выходе. В Python это
можноорганизоватьприпомощиконстантипеременных,атакженекоторымидругими
способами,которыебудутрассмотренывэтойглаве.
7.1
Комментарии
Комментарии – это то, что пишется после символа #, и представляет интерес лишь как
заметкадлячитающегопрограмму.
Например:
print ('Привет, Мир!) # print -- это функция
или:
# print -- это функция
print ('Привет, Мир!)
Старайтесьвсвоихпрограммахписатькакможнобольшеполезныхкомментариев,объ-
ясняющих:
•предположения;
•важныерешения;
•важныедетали;
•проблемы,которыевыпытаетесьрешить;
•проблемы,которыхвыпытаетесьизбежатьит.д.
Текстпрограммыговоритотом,КАК,акомментариидолжныобъяснять,ПОЧЕМУ .
Этобудетполезнодлятех,ктобудетчитатьвашупрограмму,таккакимлегчебудетпо-
нять, что программа делает. Помните, что таким человеком можете оказаться вы сами
черезполгода!
36A Byte of Python (Russian), Версия 2.02
7.2
Литеральные константы
Примером литеральной константы может быть число, например, 5,1.23,9.25e-3 или
что-нибудьвроде 'Это строка' или"It's a string!" .Ониназываютсялитеральны-
ми,потомучтоони«буквальны»1–выиспользуетеихзначениебуквально.Число 2все-
гда представляет само себя и ничего другого – это «константа», потому что её значение
нельзяизменить.Поэтомувсёэтоназываетсялитеральнымиконстантами.
7.3
Числа
ЧиславPythonбываюттрёхтипов:целые,сплавающейточкойикомплексные.
•Примеромцелогочисламожетслужить 2.
•Примерами чисел с плавающей точкой (или «плавающих» для краткости) могут
быть 3.23и52.3E-4.Обозначение Eпоказываетстепеничисла10.Вданномслучае
52.3E-4означает52.3*10-4.
•Примерыкомплексныхчисел: (-5+4j)и(2.3 - 4.6j)
Замечание для опытных программистов
Нет отдельного типа „long int“ (длинное целое). Целые числа по умолчанию могут быть
произвольнойдлины.
7.4
Строки
Строка – это последовательность символов . Чаще всего строки – это просто некоторые
наборыслов.
Слова могут быть как на английском языке, так и на любом другом, поддерживаемом
стандартомUnicode,чтоозначает почтиналюбомязыкемира .
Замечание для опытных программистов
ВPython3нетASCII-строк,потомучтоUnicodeявляетсянадмножеством(включаетвсе-
бя)ASCII.ЕслинеобходимополучитьстрокустроговкодировкеASCII,используйте str.
encode("ascii") .Подробнеесмотритев обсужденииэтоговопросанаStackOverflow .По
умолчаниювсестрокивUnicode.
1«literal»– англ.«буквальный»;вспомните«литера»( син.«буква»).( прим. перев. )
7.2. Литеральные константы 37A Byte of Python (Russian), Версия 2.02
Ямогусуверенностьюсказать,чтовыбудетеиспользоватьстрокипочтивкаждойвашей
программенаPython.Поэтомууделитевниманиетому,какработатьсострокамивPython.
7.4.1
Одинарные кавычки
Строку можно указать, используя одинарные кавычки, как например, 'Фраза в
кавычках' .Всепробелыизнакитабуляциисохранятся,какесть.
7.4.2
Двойные кавычки
Строки в двойных кавычках работают точно так же, как и в одинарных. Например,
"What's your name?" .
7.4.3
Тройные кавычки
Можноуказывать«многострочные»строкисиспользованиемтройныхкавычек( """или
''').Впределахтройныхкавычекможносвободноиспользоватьодинарныеидвойные
кавычки.Например:
'''Это многострочная строка. Это её первая строка.
Это её вторая строка.
"What's your name?", - спросил я.
Он ответил: "Bond, James Bond."
'''
7.4.4
Строки неизменяемы
Это означает, что после создания строки её больше нельзя изменять. На первый взгляд
этоможетпоказатьсянедостатком,нонасамомделеэтонетак.Впоследствиинапримере
разныхпрограмммыувидим,почемуэтонеявляетсяограничением.
7.4.5
Объединение строковых констант
Еслирасположитьрядомдвестроковыхконстанты,Pythonавтоматическиихобъединит.
Например, 'What\'s ' 'your name?' автоматически преобразуется в "What's your
name?".
7.4. Строки 38A Byte of Python (Russian), Версия 2.02
Замечание для программистов на C/C++
ВPythonнетотдельноготипаданных char(символ).Внёмнетнужды,ияуверен,чтовы
небудетепонемускучать.
Замечание для программистов на Perl/PHP
Помните,чтострокивдвойныхкавычкахиводинарныхэквивалентны,иничемдругот
друганеотличаются.
7.4.6
Метод format
Иногдабываетнужносоставитьстрокунаосновекаких-либоданных.Вотздесь-тоипри-
гождаетсяметод format() .
Сохранитеследующиестрокивфайл str_format.py :
age =26
name ='Swaroop '
print ('Возраст {0} --{1} лет. '.format(name, age))
print ('Почему {0} забавляется с этим Python? '.format(name))
Вывод:
$ python str_format.py
Возраст Swaroop -- 26 лет.
Почему Swaroop забавляется с этим Python?
Как это работает:
В строку могут быть включены определённые обозначения, а впоследствии
можетбытьвызванметод formatдлязамещенияэтихобозначенийсоответ-
ствующимиаргументами.
Взглянитенапервыйслучайпримененияобозначений,гдемыпишем {0},и
этосоответствуетпеременной name,являющейсяпервымаргументомметода
format.Аналогично,второеобозначение {1}соответствуетпеременной age,
являющейся вторым аргументом метода format. Заметьте, что Python начи-
наетотсчётс0,поэтомуперваяпозиция–номер0,вторая–номер1ит.д.
Заметьте, мы ведь могли добиться того же самого результата и объединени-
емстрок: 'Возраст' + name + ' -- ' + str(age) + ' лет.' ,однаковы
самивидите,какэтонекрасиво,икаклегковтакомслучаедопуститьошибку.
7.4. Строки 39A Byte of Python (Russian), Версия 2.02
Во-вторых,преобразованиевстрокуделаетсяметодом formatавтоматически,
в отличие от явного преобразования в нашем примере. В-третьих, используя
метод format,мыможемизменитьсообщение,незатрагиваяиспользуемых
переменных,инаоборот.
На всякий случай имейте в виду, что цифры здесь не обязательны. Можно
былобыпростонаписать:
age =26
name ='Swaroop '
print ('Возраст {}--{}лет. '.format(name, age))
print ('Почему {}забавляется с этим Python? '.format(name))
иполучитьтакойжерезультат,какиранее.
В методе formatPython помещает значение каждого аргумента в обозначенное место.
Могутбытьиболеедетальныеобозначения,както:
>>> # десятичное число (.) с точностью в 3 знака для плавающих:
>>> '{0:.3} '.format( 1/3)
'0.333'
>>> # заполнить подчёркиваниями (_) с центровкой текста (^) по ширине 11:
>>> '{0:_^11} '.format( 'hello ')
'___hello___'
>>> # по ключевым словам:
>>> '{name} написал {book} '.format(name ='Swaroop ', book ='A Byte of Python ')
'Swaroop написал A Byte of Python'
Детально такие обозначения форматов описаны в Предложении по расширению Python
PEP 3101.
7.5
Переменные
Использование одних лишь литеральных констант может скоро наскучить – нам ведь
нужен способ хранения любой информации и манипулирования ею. Вот здесь на сце-
нувыходят переменные .Слово«переменные»говоритсамозасебя–ихзначениеможет
меняться,азначит,выможетехранитьвпеременнойвсё,чтоугодно.Переменные–это
просто области памяти компьютера, в которых вы храните некоторую информацию. В
отличиеотконстант,ктакойинформациинужнокаким-тообразомполучатьдоступ,по-
этомупеременнымдаютсяимена.
7.5. Переменные 40A Byte of Python (Russian), Версия 2.02
7.6
Имена идентификаторов
Переменные–эточастныйслучайидентификаторов. Идентификаторы –этоимена,при-
своенные чему-тодляегообозначения.Привыбореимёндляидентификаторовнеобхо-
димособлюдатьследующиеправила:
•Первымсимволомидентификаторадолжнабытьбукваизалфавита(символASCIIв
верхнемилинижнемрегистре,илисимволUnicode),атакжесимволподчёркивания
(«_»).
•Остальнаячастьидентификатораможетсостоятьизбукв(символыASCIIвверхнем
или нижнем регистре, а также символы Unicode), знаков подчёркивания («_») или
цифр(0-9).
•Именаидентификаторовчувствительныкрегистру.Например, mynameиmyName–
этонеодноитоже.Обратитевниманиена« n»внижнемрегистревпервомслучае
и«N»вверхнемвовтором.
•Примеры допустимых имён идентификаторов: i,__my_name ,name_23,a1b2_c3и
любые_символы_utf8_δξѪђёўЩӆΞέά .
•Примеры недопустимых имён идентификаторов: 2things,здесь есть пробелы ,
my-name,>a1b2_c3 и"это_в_кавычках" .
7.7
Типы данных
Переменные могут хранить значения разных типов, называемых типами данных . Ос-
новными типами являются числа и строки, о которых мы уже говорили. В дальнейших
главахмыувидим,каксоздаватьсвоисобственныетипыприпомощи классов.
7.8
Объекты
Помните,Pythonрассматриваетвсё,чтоестьвпрограмме,как объекты.Имеетсяввиду,в
самомобщемсмысле.Вместотого,чтобыговорить« нечто»,мыговорим« объект».
Замечание для программистов в объектно-ориентированном стиле
Pythonстрогообъектноориентированвтомсмысле,чтообъектомявляетсявсё,включая
числа,строкиифункции.
Сейчасмыувидим,какиспользоватьпеременныенарядусконстантами.Сохранитесле-
дующийпримеризапуститепрограмму.
7.6. Имена идентификаторов 41A Byte of Python (Russian), Версия 2.02
Как писать программы на Python
ВпредьстандартнаяпроцедурасохраненияизапускапрограммынаPythonбудетвыгля-
детьтак:
1.Откройтевашлюбимыйредактор,напримерKomodoEdit.
2.Введитетекстпрограммыизпримера.
3.Сохранитееговфайл,указавегоимявкомментарии.Яследуюправилусохранять
всепрограммынаPythonсрасширением .py.
4.Запустите интерпретатор командой python3 program.py . Кроме того, вы можете
сделатьпрограмму исполнимой ,какобъяснялосьранее.
7.8.1
Пример: Использование переменных и констант
# Имя файла : var.py
i=5
print (i)
i=i+1
print (i)
s='''Это многострочная строка.
Это вторая её строчка. '''
print (s)
Вывод:
$ python var.py
5
6
Это многострочная строка.
Это вторая её строчка.
Как это работает:
Вот как эта программа работает. Сперва мы присваиваем значение констан-
ты5переменной i, используя оператор присваивания ( =). Эта строка назы-
вается предложением и указывает, что должно быть произведено некоторое
действие, и в данном случае мы связываем имя переменной iсо значением
5.Затеммыпечатаемзначение i,используяфункцию print,котораяпросто
печатаетзначениепеременнойнаэкране.
7.8. Объекты 42A Byte of Python (Russian), Версия 2.02
Далеемыдобавляем 1кзначению,хранящемусяв iисохраняемеготам.По-
слеэтогомыпечатаемегоиполучаемзначение 6,чтонеудивительно.
Аналогичнымобразоммыприсваиваемстроковуюконстантупеременной s,
послечегопечатаемеё.
Замечание для программистов на статических языках программирования
Переменные используются простым присваиванием им значений. Никакого предвари-
тельногообъявленияилиопределениятипаданныхнетребуется/применяется.
7.9
Логические и физические строки
Физическаястрока–этото,чтовы видите,когданабираетепрограмму.Логическаястро-
ка – это то, что Python видит как единое предложение. Python неявно предполагает, что
каждой физической строке соответствует логическая строка .
Примером логической строки может служить предложение print('Привет, Мир!') –
если оно на одной строке (как вы видите это в редакторе), то эта строка также соответ-
ствуетфизическойстроке.
Python неявно стимулирует использование по одному предложению на строку, что об-
легчаетчтениекода.
Чтобызаписатьболееоднойлогическойстрокинаоднойфизическойстроке,вампридёт-
сяявноуказатьэтоприпомощиточкисзапятой( ;),котораяотмечаетконецлогической
строки/предложения.Например,
i=5
print (i)
тожесамое,что
i=5;
print (i);
итожесамоеможетбытьзаписановвиде
i=5;print (i);
илидаже
i=5;print (i)
7.9. Логические и физические строки 43A Byte of Python (Russian), Версия 2.02
Однакоя настоятельно рекомендую вампридерживаться написания одной логической
строки в каждой физической строке .Такимобразомвыможетеобойтисьсовсембезточ-
кисзапятой.Кстати,я никогданеиспользовалидаженевстречалточкисзапятойвпро-
граммахнаPython.
Можноиспользоватьболееоднойфизическойстрокидлялогическойстроки,нокэтому
следуетприбегатьлишьвслучаеоченьдлинныхстрок.Примернаписанияоднойлогиче-
ской строки, занимающей несколько физических строк, приведён ниже. Это называется
явным объединением строк .
s='Это строка. \
Это строка продолжается. '
print (s)
Этодастрезультат:
Это строка .Это строка продолжается .
Аналогично,
print \
(i)
тожесамое,чтои
print (i)
Иногдаимеетместонеявноеподразумевание,когдаиспользованиеобратнойкосойчер-
ты не обязательно. Это относится к случаям, когда в логической строке есть открываю-
щаясякруглая,квадратнаяилифигурнаяскобка,нонетзакрывающейся.Этоназывается
неявным объединением строк . Вы сможете увидеть это в действии в программах с ис-
пользованием списковвдальнейшихглавах.
7.10
Отступы
В Python пробелы важны. Точнее, пробелы в начале строки важны . Это называется от-
ступами.Передниеотступы(пробелыитабуляции)вначалелогическойстрокиисполь-
зуютсядляопределенияуровняотступалогическойстроки,который,всвоюочередь,ис-
пользуетсядлягруппировкипредложений.
Этоозначает,чтопредложения,идущиевместе, должныиметьодинаковыйотступ.Каж-
дыйтакойнаборпредложенийназывается блоком.Вдальнейшихглавахмыувидимпри-
мерытого,наскольковажныблоки.
Вы должны запомнить, что неправильные отступы могут приводить к возникновению
ошибок.Например:
7.10. Отступы 44A Byte of Python (Russian), Версия 2.02
i=5
print ('Значение составляет ', i) # Ошибка! Пробел в начале строки
print ('Я повторяю, значение составляет ', i)
Когдавызапуститеэто,выполучитеследующуюошибку:
File "whitespace.py", line 4
print('Значение составляет ', i) # Ошибка! Пробел в начале строки
^
IndentationError: unexpected indent
Обратитевниманиенато,чтовначалевторойстрокиестьодинпробел.Ошибка,отобра-
жённаяPython,говоритнамотом,чтосинтаксиспрограммыневерен,т.е.программане
была написана по правилам. Для вас же это означает, что вы не можете начинать новые
блоки предложений где попало (кромеосновногоблокапоумолчанию,которыйиспользу-
етсянапротяжениивсейпрограммы,конечно).Случаи,вкоторыхвыможетеиспользо-
вать новые блоки, будут подробно описаны в дальнейших главах, как например, в главе
«Поток команд» .
Как отступать
Несмешивайте пробелы и символы табуляции в отступах, поскольку не на всех плат-
формахэтоработаеткорректно.Я настоятельно рекомендую вамиспользовать одиночную
табуляцию или четыре пробела длякаждогоуровняотступа.
Выберите какой-нибудь один из этих стилей отступа. Но что ещё более важно, это ис-
пользовать выбранный стиль постоянно , а также соблюдать стиль редактируемых вами
файлов.Т.е.когдавыпишетеновыйфайл,используйте толькоодинвашлюбимыйстиль,
аесливредактируемомвамифайледляотступовужеиспользуются,скажем,символыта-
буляции,тоивыиспользуйтевэтомфайлесимволытабуляциидляотступов.
Хорошиередакторы,такиекакKomodoEdit,будутделатьэтоавтоматически.
Замечание для программистов на статических языках программирования
Pythonвсегдабудетиспользоватьотступыдлявыделенияблоковиникогданебудетис-
пользоватьскобки.Введите from __future__ import braces ,чтобыузнатьбольше.
7.10. Отступы 45A Byte of Python (Russian), Версия 2.02
7.11
Резюме
Теперь,когдамыпрошличерезмножествожизненноважныхмелочей,можноперейтик
болееинтереснымвещам–такимкакуправляющиеконструкции.Носначалакакследует
освойтесьспрочитаннымвнастоящейглаве.
7.11. Резюме 46Операторы и выражения
Большинство предложений (логических строк) в программах содержат выражения . Про-
стойпримервыражения: 2 + 3.Выражениеможноразделитьнаоператорыиоперанды.
Операторы – это некий функционал, производящий какие-либо действия, который мо-
жет быть представлен в виде символов, как например +, или специальных зарезервиро-
ванныхслов.Операторымогутпроизводитьнекоторыедействиянадданными,иэтидан-
ныеназываются операндами .Внашемслучае 2и3–этооперанды.
8.1
Операторы
Краткорассмотримоператорыиихприменение:
Обратите внимание, вычислить значения выражений, данных в примерах, можно так-
же используя интерпретатор интерактивно. Например, для проверки выражения 2 + 3
воспользуйтесьинтерактивнойкоманднойстрокойинтерпретатораPython:
>>> 2+3
5
>>> 3*5
15
Операторы и их применение
Оператор Название Объяснение Примеры
+Сложение Суммируетдва
объекта3 + 5даст 8;'a' + 'b' даст 'ab'
-Вычита-
ниеДаётразность
двухчисел;если
первыйоперанд
отсутствует,он
считается
равнымнулю-5.2дастотрицательноечисло,а 50 -
24даст 26.
47A Byte of Python (Russian), Версия 2.02
Оператор Название Объяснение Примеры
*Умноже-
ниеДаёт
произведение
двухчиселили
возвращает
строку,
повторённую
заданноечисло
раз.2 * 3даст 6.'la' * 3 даст 'lalala' .
**Возведе-
ниев
степеньВозвращает
число х,
возведённоев
степень y3 ** 4даст 81(т.е.3 * 3 * 3 * 3 )
/Деление Возвращает
частноеот
деления xнаy4 / 3даст 1.3333333333333333 .
//Целочис-
ленное
делениеВозвращает
неполное
частноеот
деления4 // 3даст 1.-4 // 3даст -2.
%Деление
по
модулюВозвращает
остатокот
деления8 % 3даст 2.-25.5 % 2.25 даст 1.5.
<<Сдвиг
влевоСдвигаетбиты
числавлевона
заданное
количество
позиций.
(Любоечислов
памяти
компьютера
представленов
видебитов-или
двоичных
чисел,т.е.0и1)2 << 2даст 8.Вдвоичномвиде 2
представляетсобой 10.Сдвигвлевона2
битадаёт 1000,чтовдесятичномвиде
означает 8.
>>Сдвиг
вправоСдвигаетбиты
числавправона
заданноечисло
позиций.11 >> 1даст 5.Вдвоичномвиде 11
представляетсякак 1011,чтобудучи
смещённымна1битвправо,даёт 101,а
это,всвоюочередь,нечтоиноекак
десятичное 5
&Побито-
вое
ИПобитовая
операцияИнад
числами5 & 3даёт 1.
8.1. Операторы 48A Byte of Python (Russian), Версия 2.02
Оператор Название Объяснение Примеры
|Побито-
вое
ИЛИПобитовая
операцияИЛИ
надчислами5 | 3даёт 7
^Побито-
вое
ИСКЛЮ-
ЧИТЕЛЬ-
НО
ИЛИПобитовая
операцияИС-
КЛЮЧИТЕЛЬНО
ИЛИ5 ^ 3даёт 6
~Побито-
вое
НЕПобитовая
операцияНЕ
длячисла x
соответствует
-(x+1)~5даёт -6.
<Меньше Определяет,
верноли,что x
меньше y.Все
операторы
сравнения
возвращают
Trueили
False1.
Обратите
вниманиена
заглавные
буквывэтих
словах.5 < 3даст False,
а3 < 5даст True.
Можносоставлятьпроизвольныецепочки
сравнений: 3 < 5 < 7 даёт True.
>Больше Определяет,
верноли,что x
больше y5 > 3даёт True.Еслиобаоперанда-
числа,топередсравнениемониоба
преобразуютсякодинаковомутипу.В
противномслучаевсегдавозвращается
False.
<=Меньше
илиравноОпределяет,
верноли,что x
меньшеили
равно yx = 3; y = 6; x <= y даёт True.
>=Больше
илиравноОпределяет,
верноли,что x
большеили
равно yx = 4; y = 3; x >= 3 даёт True.
8.1. Операторы 49A Byte of Python (Russian), Версия 2.02
Оператор Название Объяснение Примеры
==Равно Проверяет,
одинаковыли
объектыx = 2; y = 2; x == y даёт True.x =
'str'; y = 'stR'; x == y даёт False.
x = 'str'; y = 'str'; x == y даёт
True.
!=Неравно Проверяет,
верноли,что
объектыне
равныx = 2; y = 3; x != y даёт True.
not Логиче-
ское
НЕЕсли xравно
True,оператор
вернёт False.
Еслиже xравно
False,получим
True.x = True; not x даёт False.
and Логиче-
ское
Иx and yдаёт
False,если x
равно False,в
противном
случае
возвращает
значение yx = False; y = True; x and y
возвращает False,посколькуxравно
False.ВэтомслучаеPythonнестанет
проверятьзначение y,таккакужезнает,
чтолеваячастьвыражения„and“
равняется False,чтоподразумевает,что
ивсёвыражениевцеломбудетравно
False,независимоотзначенийвсех
остальныхоперандов.Этоназывается
укороченнойоценкойбулевых
(логических)выражений.
orЛогиче-
ское
ИЛИЕсли xравно
True,в
результате
получим True,в
противном
случаеполучим
значение yx = True; y = False; x or y даёт
True.Здесьтакжеможетпроизводиться
укороченнаяоценкавыражений.
1«True»- англ.«Верно(Правда)»;«False»- англ.«Ошибочно(Ложь)».( прим. перев. )
8.1. Операторы 50A Byte of Python (Russian), Версия 2.02
8.1.1
Краткая запись мат. операций и присваивания
Зачастуюрезультатпроведениянекойматематическойоперациинеобходимоприсвоить
переменной, над которой эта операция производилась. Для этого существуют краткие
формызаписивыражений:
Выможетезаписать:
a=2; a =a*3
ввиде:
a=2; a *=3
Обратите внимание, что выражения вида « переменная = переменная операция
выражение »принимаетвид« переменная операция = выражение ».
8.2
Порядок вычисления
Еслиимеетсявыражениевида 2 + 3 * 4 ,чтопроизводитсяраньше:сложениеилиумно-
жение?Школьныйкурсматематикиговоритнам,чтоумножениедолжнопроизводиться
в первую очередь. Это означает, что оператор умножения имеет более высокий приори-
тет,чемоператорсложения.
Следующая таблица показывает приоритет операторов в Python, начиная с самого низ-
кого (самое слабое связывание) и до самого высокого (самое сильное связывание). Это
означает,чтовлюбомвыраженииPythonспервавычисляетоператорыивыражения,рас-
положенныевнизутаблицы,азатемоператорывышепотаблице.
Эта таблица взята из Справочника по языку Python (англ.) и приводится здесь для пол-
нотыописания.Напрактикелучшеиспользоватьскобкидлягруппировкиоператорови
операндов,чтобывявномвидеуказатьпорядоквычислениявыражений.Заодноэтооб-
легчит чтение программы. Более подробно см. в разделе Изменение порядка вычисления
ниже.
8.2. Порядок вычисления 51A Byte of Python (Russian), Версия 2.02
Приоритет операторов
Оператор Описание
lambda лямбда-выражение
or Логическое«ИЛИ»
and Логическое«И»
not x Логическое«НЕ»
in,not in Проверкапринадлежности
is,is not Проверкатождественности
<,<=,>,>=,!=,==Сравнения
| Побитовое«ИЛИ»
^ Побитовое«ИСКЛЮЧИТЕЛЬНОИЛИ»
& Побитовое«И»
<<,>> Сдвиги
+,- Сложениеивычитание
*,/,//,% Умножение, деление, целочисленное деление и остаток от де-
ления
+x,-x Положительное,отрицательное
~x ПобитовоеНЕ
** Возведениевстепень
x.attribute Ссылканаатрибут
x[индекс] Обращениепоиндексу
x[индекс1:индекс2] Вырезка
f(аргументы ...) Вызовфункции
(выражения, ...) Связкаиликортеж2
[выражения, ...] Список
{ключ:данные,
...}Словарь
Операторы,окоторыхмынеупомянули,будутобъясненывдальнейшихглавах.
В этой таблице операторы с равным приоритетом расположены в одной строке. Напри-
мер, +и-имеютравныйприоритет.
2«tuple»- англ.«кортеж»( прим. перев. )
8.2. Порядок вычисления 52A Byte of Python (Russian), Версия 2.02
8.3
Изменение порядка вычисления
Дляоблегчениячтениявыраженийможноиспользоватьскобки.Например, 2 + (3 * 4)
определённолегчепонять,чем 2 + 3 * 4 ,котороетребуетзнанияприоритетаоперато-
ров.Какивсёостальное,скобкинужноиспользоватьразумно(неперестарайтесь)иизбе-
гатьизлишних,какв (2 + (3 * 4)) .
Есть ещё одно преимущество в использовании скобок – они дают возможность изме-
нитьпорядоквычислениявыражений.Например,еслисложениенеобходимопроизвести
преждеумножения,можнозаписатьнечтовроде (2 + 3) * 4 .
8.4
Ассоциативность
Операторыобычнообрабатываютсяслеванаправо.Этоозначает,чтооператорысравным
приоритетомбудутобработаныпопорядкуотлевогодоправого.Например, 2 + 3 + 4
обрабатываетсякак (2 + 3) + 4 .
8.5
Выражения
Пример(сохранитекак expression.py ):
length =5
breadth =2
area =length *breadth
print ('Площадь равна ', area)
print ('Периметр равен ',2*(length +breadth))
Вывод:
$ python expression.py
Площадь равна 10
Периметр равен 14
Как это работает:
Длинаиширинапрямоугольникахранятсявпеременных lengthиbreadth
соответственно. Мы используем их для вычисления периметра и площади
прямоугольника при помощи выражений. Результат выражения length *
breadth сохраняется в переменной area, после чего выводится на экран
функцией print.Вовторомслучаемынапрямуюподставляемзначениевы-
ражения 2 * (length + breadth) вфункцию print.
8.3. Изменение порядка вычисления 53A Byte of Python (Russian), Версия 2.02
Такжеобратитевнимание,какPython«красивопечатает»результат.Несмот-
ря на то, что мы не указали пробела между 'Площадь равна' и перемен-
нойarea, Python подставляет его за нас, чтобы получить красивый и понят-
ный вывод. Программа же остаётся при этом легкочитаемой (поскольку нам
ненужнозаботитьсяопробелахмеждустроками,которыемывыводим).Это
примертого,какPythonоблегчаетжизньпрограммисту.
8.6
Резюме
Мыувидели,какпользоватьсяоператорами,операндамиивыражениями.Этоосновные
строительныеблокилюбойпрограммы.Далеемыувидим,какэтоприменитьнапракти-
ке.
8.6. Резюме 54Поток команд
Впрограммах,которыемыдосихпоррассматривали,последовательностькомандвсегда
выполняласьPythonпопорядкустрогосверхувниз.Ачто,еслинамнеобходимоизменить
потоквыполняющихсякоманд?Например,еслитребуется,чтобыпрограммапринимала
некоторое решение и выполняла различные действия в зависимости от ситуации; ска-
жем,печатала«Доброеутро»или«Добрыйвечер»взависимостиотвременисуток.
Как вы уже, наверное, догадались, этого можно достичь при помощи операторов управ-
ленияпотоком.ВPythonестьтриоператорауправленияпотоком: if,forиwhile.
9.1
Оператор if
Оператор ifиспользуетсядляпроверкиусловий: если1условиеверно2,выполняетсяблок
выражений(называемый«if-блок»), иначе3выполняетсядругойблоквыражений(назы-
ваемый«else-блок»).Блок«else»являетсянеобязательным.
Пример: (сохранитекак if.py)
number =23
guess =int(input ('Введите целое число : '))
ifguess ==number:
print ('Поздравляю, вы угадали, ')# Начало нового блока
print ('(хотя и не выиграли никакого приза!) ')# Конец нового блока
elif guess <number:
print ('Нет, загаданное число немного больше этого. ')# Ещё один блок
# Внутри блока вы можете выполнять всё, что угодно ...
else :
print ('Нет, загаданное число немного меньше этого. ')
# чтобы попасть сюда, guess должно быть больше, чем number
(продолжениенаследующейстранице)
1if–англ.«если»( прим.перев. )
2Соответствуетбулевомузначению True(прим.перев. )
3else– англ.«иначе»,«впротивномслучае»( прим.перев. )
55A Byte of Python (Russian), Версия 2.02
(продолжениеспредыдущейстраницы)
print ('Завершено ')
# Это последнее выражение выполняется всегда после выполнения оператора if
Вывод:
$ python if.py
Введите целое число : 50
Нет, загаданное число немного меньше этого.
Завершено
$ python if.py
Введите целое число : 22
Нет, загаданное число немного больше этого.
Завершено
$ python if.py
Введите целое число : 23
Поздравляю, вы угадали,
(хотя и не выиграли никакого приза!)
Завершено
Как это работает:
Вэтойпрограммемыпринимаемвариантыотпользователяипроверяем,сов-
падают ли они с заранее заданным числом. Мы устанавливаем переменной
numberзначение любого целого числа, какого хотим. Например, 23. После
этого мы принимаем вариант числа от пользователя при помощи функции
input(). Функции – это всего-навсего многократно используемые фрагмен-
тыпрограммы.Мыузнаемонихбольшев следующей главе .
Мы передаём встроенной функции inputстроку, которую она выводит на
экраниожидаетвводаотпользователя.Кактолькомыввеличто-нибудьина-
жаликлавишу Enter,функция input()возвращаетстроку,которуюмывве-
ли. Затем мы преобразуем полученную строку в число при помощи int(),
и сохраняем это значение в переменную guess. Вообще-то, int– это класс,
нонаданномэтапевамдостаточнознатьлишь,чтоприпомощинегоможно
преобразоватьстрокувцелоечисло(предполагая,чтострокасодержитцелое
число).
Далеемысравниваемчисло,введённоепользователем,счислом,котороемы
выбрали заранее. Если они равны, мы печатаем сообщение об успехе. Обра-
тите внимание, что мы используем соответствующие уровни отступа, чтобы
указатьPython,какиевыраженияотносятсяккакомублоку.Вотпочемуотсту-
пытакважнывPython.Янадеюсь,выпридерживаетесьправила«постоянных
отступов»,нетакли?
Обратитевнимание,чтовконцеоператора ifстоитдвоеточие–этиммыпо-
9.1. Оператор if 56A Byte of Python (Russian), Версия 2.02
казываем,чтодалееследуетблоквыражений.
После этого мы проверяем, верно ли, что пользовательский вариант числа
меньше загаданного, и если это так, мы информируем пользователя о том,
что ему следует выбирать числа немного больше этого. Здесь мы использо-
валивыражение elif,котороепопростуобъединяетвсебедвасвязанных if
else-if else выражения в одно выражение if-elif-else . Это облегчает
чтениепрограммы,атакженетребуетдополнительныхотступов.
Выражения elifиelseтакже имеют двоеточие в конце логической строки,
закоторымследуютсоответствующиеблокикоманд(ссоответствующимчис-
ломотступов,конечно).
Внутриif-блокаоператора ifможетбытьдругойоператор ifитакдалее–это
называетсявложенным4оператором if.
Помните, что части elifиelseне обязательны. Минимальная корректная
записьоператора ifтакова:
ifTrue :
print ('Да, это верно. ')
После того, как Python заканчивает выполнение всего оператора ifвместе с
его частями elifиelse, он переходит к следующему выражению в блоке,
содержащемэтотоператор if.Внашемслучаеэтоосновнойблокпрограммы
(в котором начинается выполнение программы), а следующее выражение –
этоprint('Завершено') .ПослеэтогоPythonдоходитдоконцапрограммыи
простовыходитизнеё.
Хотя это и чрезвычайно простая программа, я указал вам на целый ряд вещей, которые
стоитвзятьназаметку.Всёэтодовольнолегко(дажеудивительнолегкодлятехизвас,кто
пришёлизмираC/C++).Поначалувампридётсядержатьвсеэтивещивпамяти,нопосле
некоторойпрактикивыпривыкнете,ионивампокажутсявполне«естественными».
Замечание для программистов на C/C++
ВPythonнетоператора switch.Однако,припомощиконструкции if..elif..else мож-
нодостичьтогожесамого(авнекоторыхслучаяхможнодажеиспользовать словарь,что-
бысделатьэтобыстро).
4nested– англ.«вложенный»( прим.перев. )
9.1. Оператор if 57A Byte of Python (Russian), Версия 2.02
9.2
Оператор while
Оператор whileпозволяетмногократновыполнятьблоккоманддотехпор,покавыпол-
няетсянекотороеусловие.Этоодинизтакназываемых операторов цикла .Онтакжеможет
иметьнеобязательныйпункт else.
Пример: (сохранитекак while.py )
number =23
running =True
while running:
guess =int(input ('Введите целое число : '))
ifguess ==number:
print ('Поздравляю, вы угадали. ')
running =False # это останавливает цикл while
elif guess <number:
print ('Нет, загаданное число немного больше этого. ')
else :
print ('Нет, загаданное число немного меньше этого. ')
else :
print ('Цикл while закончен. ')
# Здесь можете выполнить всё что вам ещё нужно
print ('Завершение. ')
Вывод:
$ python while.py
Введите целое число : 50
Нет, загаданное число немного меньше этого.
Введите целое число : 22
Нет, загаданное число немного больше этого.
Введите целое число : 23
Поздравляю, вы угадали.
Цикл while закончен.
Завершение.
Как это работает:
В этой программе мы продолжаем играть в игру с угадыванием, но преиму-
щество состоит в том, что теперь пользователь может угадывать до тех пор,
пока не угадает правильное число, и ему не придётся запускать программу
заново для каждой попытки, как это происходило до сих пор. Это наглядно
демонстрируетприменениеоператора while.
Мы переместили операторы inputиifвнутрь цикла whileи установили
9.2. Оператор while 58A Byte of Python (Russian), Версия 2.02
переменную running в значение Trueперед запуском цикла. Прежде всего
проверяется,равнолизначениепеременной running True ,азатемпроисхо-
дит переход к соответствующему while-блоку . После выполнения этого блока
командусловие,которымвданномслучаеявляетсяпеременная running,про-
веряетсяснова.Еслионоистинно,while-блокзапускаетсяснова,впротивном
случаепроисходитпереходкдополнительномуelse-блоку,азатем–кследу-
ющемуоператору.
Блок elseвыполняется тогда, когда условие цикла whileстановится ложным ( False)
– это может случиться даже при самой первой проверке условия. Если у цикла while
имеется дополнительный блок else, он всегда выполняется, если только цикл не будет
прерваноператором break.
TrueиFalseназываются булевым типом данных, и вы можете считать их эквивалент-
нымизначениям 1и0соответственно.
Примечание для программистов на C/C++
Помните,чтоуцикла whileможетбытьблок else.
9.3
Цикл for
Оператор for..inтакжеявляетсяоператоромцикла,которыйосуществляет итерацию по
последовательностиобъектов,т.е.проходитчерезкаждыйэлементвпоследовательности.
Мыузнаембольшео последовательностях вдальнейшихглавах,апокапростозапомните,
чтопоследовательность–этоупорядоченныйнаборэлементов.
Пример: (сохранитекак for.py)
for iinrange (1,5):
print (i)
else :
print ('Цикл for закончен ')
Вывод:
$ python for.py
1
2
3
4
Цикл for закончен
9.3. Цикл for 59A Byte of Python (Russian), Версия 2.02
Как это работает:
Вэтойпрограммемывыводимнаэкран последовательность чисел.Мыгене-
рируемэтупоследовательность,используявстроеннуюфункцию range5.
Мызадаёмдвачисла,и rangeвозвращаетпоследовательностьчиселотперво-
гочисладовторого.Например, range(1,5) даётпоследовательность [1, 2,
3, 4]. По умолчанию rangeпринимает значение шага, равное 1. Если мы
зададим также и третье число range, оно будет служить шагом. Например,
range(1,5,2) даст [1,3].Помните,интервалпростираетсятолько довторо-
гочисла,т.е. невключаетеговсебя.
Обратите внимание, что range() генерирует последовательность чисел, но
только по одному числу за раз – когда оператор for запрашивает следую-
щийэлемент.Чтобыувидетьвсюпоследовательностьчиселсразу,используй-
теlist(range()) . Списки6подробно рассматриваются в главе Структуры
данных.
Затем цикл forосуществляет итерацию по этому диапазону - for i in
range(1,5) эквивалентно for i in [1, 2, 3, 4] , что напоминает при-
сваиваниепеременнойiпоодномучислу(илиобъекту)зараз,выполняяблок
команд для каждого значения i. В данном случае в блоке команд мы просто
выводимзначениенаэкран.
Помните,чтоблок elseнеобязателен.Еслионприсутствует,онвсегдавыполняетсяодин
разпослеокончанияцикла for,еслитольконеуказаноператор break.
Помнитетакже,чтоцикл for..inработаетдлялюбойпоследовательности.Внашемслу-
чаеэтосписокчисел,сгенерированныйвстроеннойфункцией range,новобщемслучае
можноиспользоватьлюбуюпоследовательностьлюбыхобъектов!Вследующихразделах
мыпознакомимсясэтимпоближе.
Примечание для программистов на C/C++/Java/C#
Цикл forв Python радикально отличается от цикла forв C/C++. Программисты на C#
заметят,чтоцикл forвPythonпохожнацикл foreachвC#.ПрограммистамнаJavaэто
можетнапомнитьконструкцию for (int i : IntArray) вJava1.5.
Если в C/C++ записать for (int i = 0; i < 5; i++) , то в Python этому соответство-
вало бы выражение for i in range(0,5) . Как видно, в Python цикл forпроще, более
выразителенименееподверженошибкам.
5range– англ.«диапазон»,«интервал»( прим.перев. )
6list– англ.«список»( прим.перев. )
9.3. Цикл for 60A Byte of Python (Russian), Версия 2.02
9.4
Оператор break
Оператор breakслужитдля прерывания7цикла,т.е.остановкивыполнениякоманддаже
если условие выполнения цикла ещё не приняло значения Falseили последователь-
ностьэлементовнезакончилась.
Важноотметить,чтоеслициклы forилиwhileпрерватьоператором break,соответству-
ющиеимблоки elseвыполняться небудут.
Пример: (сохранитекак break.py )
while True :
s=input ('Введите что-нибудь : ')
ifs=='выход ':
break
print ('Длина строки: ',len(s))
print ('Завершение ')
Вывод:
$ python break.py
Введите что-нибудь : Программировать весело.
Длина строки: 23
Введите что-нибудь : Если работа скучна,
Длина строки: 19
Введите что-нибудь : Чтобы придать ей весёлый тон -
Длина строки: 30
Введите что-нибудь : используй Python!
Длина строки: 23
Введите что-нибудь : выход
Завершение
Как это работает:
Вэтойпрограммемымногократносчитываемпользовательскийвводивыво-
димнаэкрандлинукаждойвведённойстроки.Дляостановкипрограммымы
вводим специальное условие, проверяющее, совпадает ли пользовательский
ввод со строкой 'выход'. Мы останавливаем программу прерыванием цикла
оператором breakидостигаемеёконца.
Длинавведённойстрокиможетбытьнайденаприпомощивстроеннойфунк-
цииlen.
Помнитетакже,чтооператор breakможетприменятьсяивцикле for.
7break– англ.«разбивать»,«разрывать»( прим.перев. )
9.4. Оператор break 61A Byte of Python (Russian), Версия 2.02
9.4.1
Поэтический Python Swaroop’а
Длявводастрокздесьяиспользовалмини-стишок,которыйсамсочинил.Онназывается
Поэтический Python Swaroop’а8
Программироватьвесело.
Еслиработаскучна,
Чтобыпридатьейвесёлыйтон-
используйPython!
9.5
Оператор continue
Оператор continue используется для указания Python, что необходимо пропустить все
оставшиесякомандывтекущемблокециклаи продолжить9соследующейитерациицик-
ла.
Пример: (сохранитекак continue.py )
while True :
s=input ('Введите что-нибудь : ')
ifs=='выход ':
break
iflen(s) <3:
print ('Слишком мало ')
continue
print ('Введённая строка достаточной длины ')
# Разные другие действия здесь...
Вывод:
$ python continue.py
Введите что-нибудь : a
Слишком мало
Введите что-нибудь : 12
Слишком мало
Введите что-нибудь : абв
Введённая строка достаточной длины
Введите что-нибудь : выход
8Swaroop’s Poetic Python :
Programming is fun.
When the work is done,
if you wanna make your work also fun:
use Python!
9continue– англ.«продолжать»( прим.перев. )
9.5. Оператор continue 62A Byte of Python (Russian), Версия 2.02
Как это работает:
Вэтойпрограммемызапрашиваемвводсостороныпользователя,нообраба-
тываем введённую строку только если она имеет длину хотя бы в 3 символа.
Итак,мыиспользуемвстроеннуюфункцию lenдляполучениядлиныстроки,
иеслидлинаменее3,мыпропускаемостальныедействиявблокеприпомо-
щиоператора continue .Впротивномслучаевсеостальныекомандывцикле
выполняются,производялюбыеманипуляции,которыенамнужны.
Заметьте,чтооператор continue такжеработаетисциклом for.
9.6
Резюме
Мыувидели,какиспользоватьтриоператорадляуправленияпотокомкоманд: if,while
иfor, а также связанные с ними операторы breakиcontinue . Это наиболее часто ис-
пользуемыеконструкцииPython,поэтомуовладетьимиоченьважно.
Далеемыувидим,каксоздаватьииспользоватьфункции.
9.6. Резюме 63Функции
Функции–этомногократноиспользуемыефрагментыпрограммы.Онипозволяютдать
имяопределённомублокукомандстем,чтобывпоследствиизапускатьэтотблокпоука-
занномуименивлюбомместепрограммыискольугодномногораз.Этоназывается вы-
зовомфункции.Мыужеиспользовалимноговстроенныхфункций,както lenиrange.
Функция–это,пожалуй, наиболееважныйстроительныйблоклюбойнетривиальнойпро-
граммы(налюбомязыкепрограммирования),поэтомувэтойглавемырассмотримраз-
личныеаспектыфункций.
Функции определяются при помощи зарезервированного слова def. После этого слова
указывается имяфункции, за которым следует пара скобок, в которых можно указать
имена некоторых переменных, и заключительное двоеточие в конце строки. Далее сле-
дуетблоккоманд,составляющихфункцию.Напримереможновидеть,чтонасамомделе
этооченьпросто:
Пример: (сохранитекак function1.py )
def sayHello ():
print ('Привет, Мир! ')# блок, принадлежащий функции
# Конец функции
sayHello() # вызов функции
sayHello() # ещё один вызов функции
Вывод:
$ python function1.py
Привет, Мир!
Привет, Мир!
Как это работает:
Мы определили функцию с именем sayHello , используя описанный выше
синтаксис.Этафункциянепринимаетпараметров,поэтомувскобкахнеобъ-
явлены какие-либо переменные. Параметры функции – это некие входные
данные,которыемыможемпередатьфункции,чтобыполучитьсоответству-
ющийимрезультат.
64A Byte of Python (Russian), Версия 2.02
Обратите внимание, что мы можем вызывать одну и ту же функцию много
раз,азначитнетнеобходимостиписатьодинитотжекодсноваиснова.
10.1
Параметры функций
Функциимогутприниматьпараметры,т.е.некоторыезначения,передаваемыефункции
длятого,чтобыоначто-либо сделаласними.Этипараметрыпохожинапеременные,за
исключением того, что значение этих переменных указывается при вызове функции, и
вовремяработыфункцииимужеприсвоеныихзначения.
Параметры указываются в скобках при объявлении функции и разделяются запятыми.
Аналогично мы передаём значения, когда вызываем функцию. Обратите внимание на
терминологию:имена,указанныевобъявлениифункции,называются параметрами ,то-
гдакакзначения,которыевыпередаётевфункциюприеёвызове,– аргументами .
Пример: (сохранитекак func_param.py )
def printMax (a, b):
ifa>b:
print (a, 'максимально ')
elif a==b:
print (a, 'равно ', b)
else :
print (b, 'максимально ')
printMax( 3,4)# прямая передача значений
x=5
y=7
printMax(x, y) # передача переменных в качестве аргументов
Вывод:
$ python func_param.py
4 максимально
7 максимально
Как это работает:
Здесь мы определили функцию с именем printMax , которая использует два
параметра с именами aиb. Мы находим наибольшее число с применением
простогооператора if..else ивыводимэточисло.
При первом вызове функции printMax мы напрямую передаём числа в ка-
чествеаргументов.Вовторомслучаемывызываемфункциюспеременными
10.1. Параметры функций 65A Byte of Python (Russian), Версия 2.02
вкачествеаргументов. printMax(x, y) назначаетзначениеаргумента xпа-
раметру a, а значение аргумента y– параметру b. В обоих случаях функция
printMax работаетодинаково.
10.2
Локальные переменные
Приобъявлениипеременныхвнутриопределенияфункции,ониникоимобразомнесвя-
заны с другими переменными с таким же именем за пределами функции – т.е. имена
переменныхявляются локальными вфункции.Этоназывается областью видимости пере-
менной.Областьвидимостивсехпеременныхограниченаблоком,вкоторомониобъяв-
лены,начинаясточкиобъявленияимени.
Пример: (сохранитекак func_local.py )
x=50
def func (x):
print ('x равен ', x)
x=2
print ('Замена локального x на ', x)
func(x)
print ('x по-прежнему ', x)
Вывод:
$ python func_local.py
x равен 50
Замена локального x на 2
x по-прежнему 50
Как это работает:
Припервомвыводе значения,присвоенногоимени x,впервойстрокефункции
Pythonиспользуетзначениепараметра,объявленноговосновномблоке,выше
определенияфункции.
Далее мы назначаем xзначение 2. Имя xлокально для нашей функции. По-
этомукогдамызаменяемзначение xвфункции, x,объявленныйвосновном
блоке,остаётсянезатронутым.
Последнимвызовомфункции printмывыводимзначение x,указанноевос-
новном блоке, подтверждая таким образом, что оно не изменилось при ло-
кальномприсваиваниизначениявранеевызваннойфункции.
10.2. Локальные переменные 66A Byte of Python (Russian), Версия 2.02
10.3
Зарезервированное слово «global»
Чтобыприсвоитьнекотороезначениепеременной,определённойнавысшемуровнепро-
граммы(т.е.невкакой-либообластивидимости,кактофункциииликлассы),необходимо
указатьPython,чтоеёимянелокально,а глобально (global).Сделаемэтоприпомощизаре-
зервированногослова global.Безприменениязарезервированногослова globalневоз-
можноприсвоитьзначениепеременной,определённойзапределамифункции.
Можноиспользоватьужесуществующиезначенияпеременных,определённыхзапреде-
ламифункции(приусловии,чтовнутрифункциинебылообъявленопеременнойстаким
же именем). Однако, это не приветствуется, и его следует избегать, поскольку человеку,
читающему текст программы, будет непонятно, где находится объявление переменной.
Использованиезарезервированногослова globalдостаточнояснопоказывает,чтопере-
меннаяобъявленавсамомвнешнемблоке.
Пример: (сохранитекак func_global.py )
x=50
def func ():
global x
print ('x равно ', x)
x=2
print ('Заменяем глобальное значение x на ', x)
func()
print ('Значение x составляет ', x)
Вывод:
$ python func_global.py
x равно 50
Заменяем глобальное значение x на 2
Значение x составляет 2
Как это работает:
Зарезервированноеслово globalиспользуетсядлятого,чтобыобъявить,что
x–этоглобальнаяпеременная,азначит,когдамыприсваиваемзначениеиме-
ниxвнутрифункции,этоизменениеотразитсяназначениипеременной xв
основномблокепрограммы.
Используя одно зарезервированное слово global, можно объявить сразу
несколькопеременных: global x, y, z .
10.3. Зарезервированное слово «global» 67A Byte of Python (Russian), Версия 2.02
10.4
Зарезервированное слово «nonlocal»
Мы увидели, как получать доступ к переменным в локальной и глобальной области ви-
димости.Естьещёодинтипобластивидимости,называемый«нелокальной»( nonlocal )
областью видимости, который представляет собой нечто среднее между первыми дву-
мя.Нелокальныеобластивидимостивстречаются,когдавыопределяетефункциивнутри
функций.
ПосколькувPythonвсёявляетсявыполнимымкодом,выможетеопределятьфункциигде
угодно.
Давайте рассмотрим пример:
# Filename: func_nonlocal.py
def func_outer ():
x=2
print ('x равно ', x)
def func_inner ():
nonlocal x
x=5
func_inner()
print ('Локальное x сменилось на ', x)
func_outer()
Вывод:
$ python func_nonlocal.py
x равно 2
Локальное x сменилось на 5
Как это работает:
Когдамынаходимсявнутри func_inner ,переменная x,определённаявпер-
вой строке func_outer находится ни в локальной области видимости (опре-
деление переменной не входит в блок func_inner ), ни в глобальной обла-
сти видимости (она также и не в основном блоке программы). Мы объявля-
ем, что хотим использовать именно эту переменную x, следующим образом:
nonlocal x .
Попробуйтезаменить« nonlocal x »на« global x »,азатемудалитьэтоза-
резервированное слово, и пронаблюдайте за разницей между этими двумя
случаями.
10.4. Зарезервированное слово «nonlocal» 68A Byte of Python (Russian), Версия 2.02
10.5
Значения аргументов по умолчанию
Зачастую часть параметров функций могут быть необязательными , и для них будут ис-
пользоватьсянекоторыезаданныезначенияпоумолчанию,еслипользовательнеукажет
собственных.Этогоможнодостичьспомощьюзначенийаргументовпоумолчанию.Их
можно указать, добавив к имени параметра в определении функции оператор присваи-
вания( =)споследующимзначением.
Обратите внимание, что значение по умолчанию должно быть константой. Или точнее
говоря,онодолжнобытьнеизменным1–этообъясняетсяподробнеевпоследующихгла-
вах.Апоказапомнитеэто.
Пример: (сохранитекак func_default.py )
def say(message, times =1):
print (message *times)
say( 'Привет ')
say( 'Мир',5)
Вывод:
$ python func_default.py
Привет
МирМирМирМирМир
Как это работает:
Функцияподименем sayиспользуетсядлявыводанаэкранстрокиуказанное
числораз.Еслимынеуказываемзначения,поумолчаниюстрокавыводится
одинраз.Мыдостигаемэтогоуказаниемзначенияаргументапоумолчанию,
равного 1дляпараметра times2.
При первом вызове sayмы указываем только строку, и функция выводит её
одинраз.Привторомвызове sayмыуказываемтакжеиаргумент 5,обозначая
такимобразом,чтомыхотим сказать3фразу5раз.
Важно:Значениямипоумолчаниюмогутбытьснабженытолькопараметры,находящи-
еся в конце списка параметров. Таким образом, в списке параметров функции параметр
созначениемпоумолчаниюнеможетпредшествоватьпараметрубеззначенияпоумол-
чанию. Это связано с тем, что значения присваиваются параметрам в соответствии с их
положением.Например, def func(a, b=5) допустимо,а def func(a=5, b) –не допустимо .
1«immutable»втерминологииPython( прим. перев. )
2times– англ.«раз»( прим. перев. )
3say– англ.«сказать»( прим. перев. )
10.5. Значения аргументов по умолчанию 69A Byte of Python (Russian), Версия 2.02
10.6
Ключевые аргументы
Если имеется некоторая функция с большим числом параметров, и при её вызове тре-
буется указать только некоторые из них, значения этих параметров могут задаваться по
ихимени–этоназывается ключевые параметры .Вэтомслучаедляпередачиаргументов
функциииспользуетсяимя(ключ)вместопозиции(какбылодосихпор).
Есть два преимущества такого подхода: во-первых, использование функции становится
легче,посколькунетнеобходимостиотслеживатьпорядокаргументов;во-вторых,можно
задавать значения только некоторым избранным аргументам, при условии, что осталь-
ныепараметрыимеютзначенияаргументапоумолчанию.
Пример: (сохранитекак func_key.py )
def func (a, b =5, c=10):
print ('a равно ', a, ', b равно ', b, ', а c равно ', c)
func( 3,7)
func( 25, c=24)
func(c =50, a=100)
Вывод:
$ python func_key.py
a равно 3, b равно 7, а c равно 10
a равно 25, b равно 5, а c равно 24
a равно 100, b равно 5, а c равно 50
Как это работает:
Функциясименем funcимеетодинпараметрбеззначенияпоумолчанию,за
которымследуютдвапараметрасозначениямипоумолчанию.
При первом вызове, func(3, 7) , параметр aполучает значение 3, параметр
bполучаетзначение 7,аcполучаетсвоёзначениепоумолчанию,равное 10.
При втором вызове func(25, c=24) переменная aполучает значение 25 в
силу позиции аргумента. После этого параметр cполучает значение 24по
имени,т.е.какключевойпараметр.Переменная bполучаетзначениепоумол-
чанию,равное 5.
Притретьемобращении func(c=50, a=100) мыиспользуемключевыеаргу-
менты для всех указанных значений. Обратите внимание на то, что мы ука-
зываем значение для параметра cперед значением для a, даже несмотря на
то,чтовопределениифункциипараметр aуказанраньше c.
10.6. Ключевые аргументы 70A Byte of Python (Russian), Версия 2.02
10.7
Переменное число параметров4
Иногдабываетнужноопределитьфункцию,способнуюпринимать любоечислопарамет-
ров.Этогоможнодостичьприпомощизвёздочек(сохранитекак function_varargs.py ):
def total (a=5,*numbers, **phonebook):
print ('a', a)
#проход по всем элементам кортежа
for single_item innumbers:
print ('single_item ', single_item)
#проход по всем элементам словаря
for first_part, second_part inphonebook .items():
print (first_part,second_part)
print (total( 10,1,2,3,Jack =1123 ,John =2231 ,Inge =1560 ))
Вывод:
$ python function_varargs.py
a 10
single_item 1
single_item 2
single_item 3
Inge 1560
John 2231
Jack 1123
None
Как это работает:
Когдамыобъявляемпараметрсозвёздочкой(например, *param),всепозици-
онныеаргументыначинаясэтойпозицииидоконцабудутсобранывкортеж
подименем param.
Аналогично,когдамыобъявляемпараметрысдвумязвёздочками( **param),
всеключевыеаргументыначинаясэтойпозицииидоконцабудутсобраныв
словарьподименем param.
Мыизучимкортежиисловарив одной из последующих глав .
4VarArgs– от англ.«Variablenumberof Argument s»–«переменноечислоаргументов»( прим. перев. )
10.7. Переменное число параметров471A Byte of Python (Russian), Версия 2.02
10.8
Только ключевые параметры
Еслинекоторыеключевыепараметрыдолжныбытьдоступнытолькопоключу,а некак
позиционныеаргументы,ихможнообъявитьпослепараметрасозвёздочкой(сохраните
какkeyword_only.py ):
def total (initial =5,*numbers, extra_number):
count =initial
for number innumbers:
count +=number
count +=extra_number
print (count)
total( 10,1,2,3, extra_number =50)
total( 10,1,2,3)
# Вызовет ошибку, поскольку мы не указали значение
# аргумента по умолчанию для 'extra_number'.
Вывод:
$ python keyword_only.py
66
Traceback (most recent call last):
File "keyword_only.py", line 12, in <module>
total(10, 1, 2, 3)
TypeError: total() needs keyword-only argument extra_number
Как это работает:
Объявлениепараметровпослепараметрасозвёздочкойдаёттолькоключевые
аргументы.Еслидлятакихаргументовнеуказанозначениепоумолчанию,и
ононепереданопривызове,обращениекфункциивызоветошибку,вчёммы
толькочтоубедились.
Обратитевниманиенаиспользование +=,которыйпредставляетсобойсокра-
щённыйоператор,позволяющийвместо x = x + y простонаписать x += y.
Есливамнужныаргументы,передаваемыетолькопоключу,ноненуженпа-
раметр со звёздочкой, то можно просто указать одну звёздочку без указания
имени: def total(initial=5, *, extra_number) .
10.8. Только ключевые параметры 72A Byte of Python (Russian), Версия 2.02
10.9
Оператор «return»
Оператор returnиспользуетсядлявозврата5изфункции,т.е.дляпрекращенияеёработы
ивыходаизнеё.Приэтомможнотакже вернуть некоторое значение изфункции.
Пример: (сохранитекак func_return.py )
#!/usr/bin/python
# Filename: func_return.py
def maximum (x, y):
ifx>y:
return x
elif x==y:
return 'Числа равны. '
else :
return y
print (maximum( 2,3))
Вывод:
$ python func_return.py
3
Как это работает:
Функция maximumвозвращаетмаксимальныйиздвухпараметров,которыев
данномслучаепередаютсяейпривызове.Онаиспользуетобычныйусловный
оператор if..else дляопределениянаибольшегочисла,азатем возвращает
эточисло.
Обратитевнимание,чтооператор returnбезуказаниявозвращаемогозначенияэквива-
лентенвыражению return None .None–этоспециальныйтипданныхвPython,обозна-
чающийничего.Кпримеру,еслизначениепеременнойустановленов None,этоозначает,
чтоейнеприсвоеноникакогозначения.
Каждая функция содержит в неявной форме оператор return None в конце, если вы
не указали своего собственного оператора return. В этом можно убедиться, запустив
print(someFunction()) , где функция someFunction – это какая-нибудь функция, не
имеющаяоператора returnвявномвиде.Например:
def someFunction ():
pass
Оператор passиспользуетсявPythonдляобозначенияпустогоблокакоманд.
5return– англ.«возврат»( прим. перев. )
10.9. Оператор «return» 73A Byte of Python (Russian), Версия 2.02
Примечание: Существуетвстроеннаяфункция max,вкоторойужереализованфункци-
онал «поиск максимума», так что пользуйтесь этой встроенной функцией, где это воз-
можно.
10.10
Строки документации6
Python имеет остроумную особенность, называемую строками документации , обычно
обозначаемуюсокращённо docstrings.Этооченьважныйинструмент,которымвыобяза-
тельнодолжныпользоваться,посколькуонпомогаетлучшедокументироватьпрограмму
иоблегчаетеёпонимание.Поразительно,нострокудокументацииможнополучить,на-
пример,изфункции,дажевовремявыполненияпрограммы!
Пример: (сохранитекак func_doc.py )
def printMax (x, y):
'''Выводит максимальное из двух чисел.
Оба значения должны быть целыми числами.'''
x=int(x) # конвертируем в целые, если возможно
y=int(y)
ifx>y:
print (x, 'наибольшее ')
else :
print (y, 'наибольшее ')
printMax( 3,5)
print (printMax .__doc__ )
Вывод:
$ python func_doc.py
5 наибольшее
Выводит максимальное из двух чисел.
Оба значения должны быть целыми числами.
Как это работает:
Строкавпервойлогическойстрокефункцииявляется строкой документации
для этой функции. Обратите внимание на то, что строки документации при-
менимытакжек модулямиклассам,окоторыхмыузнаемвсоответствующих
6DocString- от англ.«Documentation String»–«строкадокументации»( прим. перев. )
10.10. Строки документации674A Byte of Python (Russian), Версия 2.02
главах.
Строки документации принято записывать в форме многострочной7строки,
гдеперваястроканачинаетсясзаглавнойбуквыизаканчиваетсяточкой.Вто-
рая строка оставляется пустой, а подробное описание начинается с третьей.
Вам настоятельно рекомендуется следовать такому формату для всех строк
документациивсехвашихнетривиальныхфункций.
Доступ к строке документации функции printMax можно получить с помо-
щьюатрибутаэтойфункции(т.е.имени,принадлежащегоей) __doc__(обра-
тите внимание на двойное подчёркивание ). Просто помните, что Python пред-
ставляет всёввидеобъектов,включаяфункции.Мыузнаембольшеобобъек-
тахвглаве о классах.
Если вы пользовались функцией help()в Python, значит вы уже видели строки доку-
ментации. Эта функция просто-напросто считывает атрибут __doc__ соответствующей
функции и аккуратно выводит его на экран. Вы можете проверить её на рассмотренной
выше функции: просто включите help(printMax) в текст программы. Не забудьте на-
жатьклавишу qдлявыходаизсправки( help).
Точно так же автоматические инструменты могут получать документацию из програм-
мы.Именнопоэтомуя настоятельно рекомендую вамиспользоватьстрокидокументации
для любой нетривиальной функции, которую вы пишете. Команда pydoc, поставляемая
вместеспакетомPython,работаетаналогичнофункции help().
10.11
Аннотации
Функцииимеютещёоднудополнительнуювозможность,называемуюаннотациями,ко-
торые предоставляют отличный способ сопровождения каждого параметра, равно как и
возвращаемого значения дополнительной информацией. Поскольку сам язык Python не
интерпретируетэтианнотациикаким-либоспособом(этотфункционалотводитсяпосто-
ронним библиотекам), мы опустим эту возможность из нашего обсуждения. Если вам
интереснопочитатьобаннотациях,просмотрите PEP 3107.
10.12
Резюме
Мы рассмотрели достаточно много аспектов функций, но тем не менее, вы должны по-
нимать,чтоэтодалеконевсеихаспекты.Втожевремя,мыохватилибольшинствотого,
счемвыбудетесталкиватьсяприповседневномиспользованиифункцийвPython.
Далеемыувидим,какиспользоватьисоздаватьмодулиPython.
7т.е.строки,содержащейсимволыпереводастроки.( прим. перев )
10.11. Аннотации 75Модули
Как можно использовать код повторно, помещая его в функции, мы уже видели. А что,
еслинампонадобитсяповторноиспользоватьразличныефункциивдругихнашихпро-
граммах?Каквыуже,наверное,догадались,ответ–модули.
Существуютразныеспособысоставлениямодулей,носамыйпростой–этосоздатьфайл
срасширением .py,содержащийфункцииипеременные.
Другойспособ–написатьмодульнатомязыкепрограммирования,накоторомнаписан
сам интерпретатор Python. Например, можно писать модули на языке программирова-
нияC,которыепослекомпиляциимогутиспользоватьсястандартныминтерпретатором
Python.
Модуль можно импортировать в другую программу, чтобы использовать функции из
него. Точно так же мы используем стандартную библиотеку Python. Сперва посмотрим,
какиспользоватьмодулистандартнойбиблиотеки.
Пример: (сохранитекак using_sys.py )
import sys
print ('Аргументы командной строки: ')
for iinsys.argv:
print (i)
print ('\n\nПеременная PYTHONPATH содержит ', sys .path, '\n')
Вывод:
$ python3 using_sys.py we are arguments
Аргументы командной строки:
using_sys.py
we
are
arguments
Переменная PYTHONPATH содержит ['', 'C:\\Windows\\system32\\python30.zip',
'C:\\Python30\\DLLs', 'C:\\Python30\\lib',
(продолжениенаследующейстранице)
76A Byte of Python (Russian), Версия 2.02
(продолжениеспредыдущейстраницы)
'C:\\Python30\\lib\\plat-win', 'C:\\Python30',
'C:\\Python30\\lib\\site-packages']
Как это работает:
В начале мы импортируем модуль sysкомандой import. Этим мы говорим
Python,чтохотимиспользоватьэтотмодуль.Модуль sysсодержитфункции,
относящиесякинтерпретаторуPythonиегосреде,т.е.к системе( system).
КогдаPythonвыполняеткоманду import sys ,онищетмодуль sys.Вданном
случаеэтоодинизвстроенныхмодулей,иPythonзнает,гдеегоискать.
Если бы это был не скомпилированный модуль, т.е. модуль, написанный на
Python,тогдаинтерпретаторPythonискалбыеговкаталогах,перечисленных
в переменной sys.path . Если модуль найден, выполняются команды в теле
модуля,ионстановится доступным .Обратитевнимание,чтоинициализация1
происходиттолькопри первомимпортемодуля.
Доступкпеременной argvвмодуле sysпредоставляетсяприпомощиточки,
т.е.sys.argv .Этоявнопоказывает,чтоэтоимяявляетсячастьюмодуля sys.
Ещёоднимпреимуществомтакогообозначенияявляетсято,чтоимянекон-
фликтуетсименемпеременной argv,котораяможетиспользоватьсяввашей
программе.
Переменная sys.argv является спискомстрок(спискибудутдетальнообсуж-
датьсяв одной из последующих глав ).Онасодержитсписок аргументов команд-
ной строки ,т.е.аргументов,переданныхпрограммеизкоманднойстроки.
Если вы используете среду разработки2для написания и запуска программ,
поищите где-нибудь в её меню возможность передавать параметры команд-
нойстроки.
В нашем примере, когда мы запускаем « python using_sys.py we are
arguments », мы запускаем модуль using_sys.py командой python, а всё,
что следует далее – аргументы, передаваемые программе3. Python сохраняет
аргументы командной строки в переменной sys.argv для дальнейшего ис-
пользования.
Помните, что имя запускаемого сценария4всегда является первым аргумен-
томвсписке sys.argv .Такчтовприведённомпримере 'using_sys.py' бу-
дет элементом sys.argv[0] ,'we'–sys.argv[1] ,'are'–sys.argv[2] , а
1Инициализация–ряддействий,производимыхприначальнойзагрузке( прим. перев. )
2IDE– от англ.«IntegratedDevelopmentEnvironment»–«интегрированнаясредаразработки»( прим. пе-
рев.)
3«wearearguments»– англ.«мыаргументы»( прим. перев. )
4Программунаинтерпретируемомязыкепрограммированиятакженазывают сценарием или скриптом
(прим. перев. )
77A Byte of Python (Russian), Версия 2.02
'arguments' –sys.argv[3] .Помните,чтовPythonнумерацияначинаетсяс
0,анес1.
sys.path содержит список имён каталогов, откуда импортируются модули.
Заметьте, что первая строка в sys.path пуста; эта пустая строка показывает,
чтотекущаядиректориятакжеявляетсячастью sys.path ,котораясовпадает
со значением переменной окружения PYTHONPATH . Это означает, что моду-
ли, расположенные в текущем каталоге, можно импортировать напрямую. В
противном случае придётся поместить свой модуль в один из каталогов, пе-
речисленныхв sys.path .
Помните, что текущий каталог – это каталог, в котором была запущена про-
грамма. Выполните « import os; print(os.getcwd()) », чтобы узнать те-
кущийкаталогпрограммы.
11.1
Файлы байткода .pyc
Импортмодуля–относительнодорогостоящеемероприятие,поэтомуPythonпредприни-
мает некоторые трюки для ускорения этого процесса. Один из способов – создать байт-
компилированные файлы (или байткод) с расширением .pyc, которые являются некой
промежуточнойформой,вкоторуюPythonпереводитпрограмму(помнитераздел «Введе-
ние»отом,какработаетPython?).Такойфайл .pycполезенприимпортемодулявследу-
ющийразвдругуюпрограмму–этопроизойдётнамногобыстрее,посколькузначитель-
наячастьобработки,требуемойприимпортемодуля,будетужепроделана.Этотбайткод
такжеявляетсяплатформо-независимым.
Примечание: Обычнофайлы .pycсоздаютсявтомжекаталоге,гдерасположеныисо-
ответствующиеимфайлы .py.ЕслиPythonнеможетполучитьдоступдлязаписифайлов
вэтоткаталог,файлы .pycсозданынебудут.
11.2
Оператор from … import …
Чтобыимпортироватьпеременную argvпрямовпрограммуинеписатьвсякийраз sys.
приобращениикней,можновоспользоватьсявыражением« from sys import argv ».
Для импорта всех имён, использующихся в модуле sys, можно выполнить команду
«from sys import * ».Этоработаетдлялюбыхмодулей.
Вобщемслучаевам следует избегать использованияэтогооператораииспользоватьвме-
стоэтогооператор import,чтобыпредотвратитьконфликтыимёнинезатруднятьчтение
программы.
11.1. Файлы байткода .pyc 78A Byte of Python (Russian), Версия 2.02
Пример:
from math import *
n=int(input ("Введите диапазон:- "))
p=[2,3]
count =2
a=5
while (count <n):
b=0
for iinrange (2,a):
if( i <=sqrt(a)):
if(a%i==0):
print (a,"непростое ")
b=1
else :
pass
if(b!=1):
print (a,"простое ")
p=p+[a]
count =count +1
a=a+2
print (p)
11.3
Имя модуля – __name__
Укаждогомодуляестьимя,икомандывмодулемогутузнатьимяихмодуля.Этополезно,
когданужнознать,запущенлимодулькаксамостоятельнаяпрограммаилиимпортиро-
ван.Какужеупоминалосьвыше,когдамодульимпортируетсявпервые,содержащийсяв
нёмкодисполняется.Мыможемвоспользоватьсяэтимдлятого,чтобызаставитьмодуль
вестисебяпо-разномувзависимостиоттого,используетсялионсампосебеилиимпор-
тируетсявдругуюпрограмма.Этогоможнодостичьсприменениематрибутамодуляпод
названием __name__ .
Пример: (сохранитекак using_name.py )
if__name__ =='__main__ ':
print ('Эта программа запущена сама по себе. ')
else :
print ('Меня импортировали в другой модуль. ')
Вывод:
$ python3 using_name.py
Эта программа запущена сама по себе.
(продолжениенаследующейстранице)
11.3. Имя модуля – __name__ 79A Byte of Python (Russian), Версия 2.02
(продолжениеспредыдущейстраницы)
$ python3
>>> import using_name
Меня импортировали в другой модуль.
>>>
Как это работает:
В каждом модуле Python определено его имя – __name__5. Если оно равно
'__main__' , это означает, что модуль запущен самостоятельно пользовате-
лем,имыможемвыполнитьсоответствующиедействия.
11.4
Создание собственных модулей
Создатьсобственныймодульоченьлегко.Давывсёвремяделалиэто!Ведькаждаяпро-
грамманаPythonтакжеявляетсяимодулем.Необходимолишьубедиться,чтоунеёуста-
новленорасширение .py.Следующийпримеробъяснитэто.
Пример: (сохранитекак mymodule.py )
def sayhi ():
print ('Привет! Это говорит мой модуль. ')
__version__ ='0.1'
# Конец модуля mymodule.py
Вышеприведёнпростой модуль.Каквидно,внёмнетничегоособенногопосравнениюс
обычнойпрограммойнаPython.Далеепосмотрим,какиспользоватьэтотмодульвдругих
нашихпрограммах.
Помните,чтомодульдолженнаходитьсялибовтомжекаталоге,чтоипрограмма,вко-
торуюмыимпортируемего,либоводномизкаталогов,указанныхв sys.path .
Ещёодинмодуль(сохранитекак mymodule_demo.py ):
import mymodule
mymodule .sayhi()
print ('Версия ', mymodule .__version__)
5name- англ.«имя»( прим. перев. )
11.4. Создание собственных модулей 80A Byte of Python (Russian), Версия 2.02
Вывод:
$ python mymodule_demo.py
Привет! Это говорит мой модуль.
Версия 0.1
Как это работает:
Обратитевнимание,чтомыиспользуемвсётожеобозначениеточкойдлядо-
ступакэлементаммодуля.Pythonповсеместноиспользуетодноитожеобо-
значение точкой, придавая ему таким образом характерный «Python-овый»
видиневынуждаянасизучатьвсёновыеиновыеспособыделатьчто-либо.
Вот версия, использующая синтаксис from..import (сохраните как mymodule_demo2.
py):
from mymodule import sayhi, __version__
sayhi()
print ('Версия ', __version__)
Вывод mymodule_demo2.py такойже,каки mymodule_demo.py .
Обратитевнимание,чтоесливмодуле,импортирующемданныймодуль,ужебылообъ-
явлено имя __version__ , возникнет конфликт. Это весьма вероятно, так как объявлять
версиюлюбогомодуляприпомощиэтогоимени–общепринятаяпрактика.Поэтомувсе-
гда рекомендуется отдавать предпочтение оператору import, хотя это и сделает вашу
программунемногодлиннее.
Вымоглибытакжеиспользовать:
from mymodule import *
Это импортирует все публичные имена, такие как sayhi, но не импортирует
__version__ ,потомучтоононачинаетсясдвойногоподчёркивания
Дзэн Python
ОднимизруководящихпринциповвPythonявляется«ЯвноелучшеНеявного».Выпол-
ните команду « import this », чтобы узнать больше, а также просмотрите это обсужде-
ние,вкоторомприводятсяпримерыпокаждомуизпринципов.
11.4. Создание собственных модулей 81A Byte of Python (Russian), Версия 2.02
11.5
Функция dir
Встроеннаяфункция dir()возвращаетсписокимён,определяемыхобъектом.Например,
для модуля в этот список входят функции, классы и переменные, определённые в этом
модуле.
Этафункцияможетприниматьаргументы.Есливкачествеаргументауказаноимямоду-
ля,онавозвращаетсписокимён,определённыхвэтоммодуле.Еслиникакогоаргумента
непередавать,онавернётсписокимён,определённыхвтекущеммодуле.
Пример:
$ python3
>>> import sys # получим список атрибутов модуля 'sys'
>>> dir(sys)
['__displayhook__', '__doc__', '__excepthook__', '__name__', '__package__',
'__stderr__', '__stdin__', '__stdout__', '_clear_type_cache', '_compact_free
lists', '_current_frames', '_getframe', 'api_version', 'argv', 'builtin_module
_names', 'byteorder', 'call_tracing', 'callstats', 'copyright', 'displayhook',
'dllhandle', 'dont_write_bytecode', 'exc_info', 'excepthook', 'exec_prefix',
'executable', 'exit', 'flags', 'float_info', 'getcheckinterval', 'getdefault
encoding', 'getfilesystemencoding', 'getprofile', 'getrecursionlimit', 'getref
count', 'getsizeof', 'gettrace', 'getwindowsversion', 'hexversion', 'intern',
'maxsize', 'maxunicode', 'meta_path', 'modules', 'path', 'path_hooks',
'path_importer_cache', 'platform', 'prefix', 'ps1', 'ps2', 'setcheckinterval',
'setprofile', 'setrecursionlimit', 'settrace', 'stderr', 'stdin', 'stdout',
'subversion', 'version', 'version_info', 'warnoptions', 'winver']
>>> dir() # получим список атрибутов текущего модуля
['__builtins__', '__doc__', '__name__', '__package__', 'sys']
>>> a = 5 # создадим новую переменную 'a'
>>> dir()
['__builtins__', '__doc__', '__name__', '__package__', 'a', 'sys']
>>> del a # удалим имя 'a'
>>> dir()
['__builtins__', '__doc__', '__name__', '__package__', 'sys']
>>>
Как это работает:
Сперва мы видим результат применения dirк импортированному модулю
11.5. Функция dir 82A Byte of Python (Russian), Версия 2.02
sys.Видимогромныйсписокатрибутов,содержащихсявнём.
Затем мы вызываем функцию dir, не передавая ей параметров. По умолча-
нию,онавозвращаетсписокатрибутовтекущегомодуля.Обратитевнимание,
чтосписокимпортированныхмодулейтакжевходиттуда.
Чтобы пронаблюдать за действием dir, мы определяем новую переменную
aи присваиваем ей значение, а затем снова вызываем dir. Видим, что в
полученном списке появилось дополнительное значение. Удалим перемен-
ную/атрибут из текущего модуля при помощи оператора del, и изменения
вновьотобразятсянавыводефункции dir.
Замечаниепоповоду del:этотоператориспользуетсядля удаленияперемен-
ной/имени,ипослееговыполнения,вданномслучае– del a,кпеременной
aбольшеневозможнообратиться–еёкакбудтоникогдаинебыло.
Обратитевнимание,чтофункция dir()работаетдля любогообъекта.Напри-
мер, выполните « dir('print') », чтобы увидеть атрибуты функции print,
или« dir(str) »,чтобыувидетьатрибутыкласса str.
11.6
Пакеты
Кнастоящемувременивы,вероятно,началинаблюдатьнекоторуюиерархиюворганиза-
циивашихпрограмм.Переменныеобычнонаходятсявфункциях.Функциииглобальные
переменные обычно находятся в модулях. А что, если возникнет необходимость как-то
организоватьмодули?Вотздесь-тоивыходятнасценупакеты.
Пакеты–этопростокаталогисмодулямииспециальнымфайлом __init__.py ,который
показываетPython,чтоэтоткаталогособый,таккаксодержитмодулиPython.
Представим, что мы хотим создать пакет под названием «world» с субпакетами «asia»,
«africa»ит.д.,которые,всвоюочередь,будутсодержатьмодули«india»,«madagascar»и
т.д.
Дляэтогоследовалобысоздатьследующуюструктурукаталогов:
|-<некоторый каталог из sys .path >/
||----world /
| |----__init__ .py
| |----asia /
| | |----__init__ .py
| | |----india /
| | |----__init__ .py
| | |----foo.py
| |----africa /
| |----__init__ .py
(продолжениенаследующейстранице)
11.6. Пакеты 83A Byte of Python (Russian), Версия 2.02
(продолжениеспредыдущейстраницы)
| |----madagascar /
| |----__init__ .py
| |----bar.py
Пакеты – это удобный способ иерархически организовать модули. Такое часто встреча-
етсяв стандартной библиотеке .
11.7
Резюме
Точно так же, как функции являются многократно используемыми фрагментами про-
грамм, модули являются многократно используемыми программами. Пакеты – это спо-
собиерархическойорганизациимодулей.СтандартнаябиблиотекаPythonявляетсяпри-
меромтакогонаборапакетовимодулей.
Мыувидели,какпользоватьсяэтимимодулямиисоздаватьсвои.
Далее мы познакомимся с некоторыми интересными концепциями, называемыми
«структурыданных».
11.7. Резюме 84Структуры данных
Структуры данных – это, по сути, и есть структуры , которые могут хранить некоторые
данныевместе.Другимисловами,онииспользуютсядляхранениясвязанныхданных.
В Python существуют четыре встроенных структуры данных: список, кортеж, словарь и
множество.Посмотрим,какимипользоваться,икаконимогутоблегчитьнамжизнь.
12.1
Список
Список1–этоструктураданных,котораясодержитупорядоченныйнаборэлементов,т.е.
хранит последовательность элементов.Этолегкопредставить,есливспомнитьсписокпо-
купок,вкоторомперечисляется,чтонужнокупить,стемлишьисключением,чтовсписке
покупок каждый элемент обычно размещается на отдельной строке, тогда как в Python
ониразделяютсязапятыми.
Списокэлементовдолженбытьзаключёнвквадратныескобки,чтобыPythonпонял,что
это список. Как только список создан, можно добавлять, удалять или искать элементы
в нём. Поскольку элементы можно добавлять и удалять, мы говорим, что список – это
изменяемый типданных,т.е.егоможномодифицировать.
12.2
Краткое введение в объекты и классы
Хотяяистаралсядосихпороттянутьобсуждениеобъектовиклассов,наданномэтапевсё
женеобходимонекотороепояснение,чтобывылучшепонялиидеюсписков.Мыизучим
этутемудетальнов её собственной главе .
Список–этоодинизпримеровиспользованияобъектовиклассов.Когдамыназначаем
некоторой переменной iзначение, скажем, целое число 5, это можно представить себе
каксоздание объекта(т.е.экземпляра) iкласса(т.е.типа) int.Чтобылучшепонятьэто,
прочитайте help(int) .
Классможеттакжеиметь методы,т.е.функции,определённыедляиспользованиятолько
применительнокданномуклассу.Этотфункционалбудетдоступентолькокогдаимеется
1list– англ.«список»( прим.перев. )
85A Byte of Python (Russian), Версия 2.02
объект данного класса. Например, Python предоставляет метод appendдля класса list,
которыйпозволяетдобавлятьэлементкконцусписка.Так mylist.append('and item')
добавитэтустрокуксписку mylist.Обратитевниманиенаобозначениеточкойдлядо-
ступакметодамобъектов.
Класстакжеможетиметь поля,которыепредставляютсобойнечтоиное,какпеременные,
определённыедляиспользованиятолькоприменительнокданномуклассу.Этиперемен-
ные/именаможноиспользоватьтолькотогда,когдаимеетсяобъектэтогокласса.Доступ
кполямтакжеосуществляетсяприпомощиточки.Например, mylist.field .
Пример: (сохранитекак using_list.py )
# Это мой список покупок
shoplist =['яблоки ','манго ','морковь ','бананы ']
print ('Я должен сделать ',len(shoplist), 'покупки. ')
print ('Покупки: ', end ='')
for item inshoplist:
print (item, end ='')
print ('\nТакже нужно купить риса. ')
shoplist .append( 'рис')
print ('Теперь мой список покупок таков: ', shoplist)
print ('Отсортирую-ка я свой список ')
shoplist .sort()
print ('Отсортированный список покупок выглядит так: ', shoplist)
print ('Первое, что мне нужно купить, это ', shoplist[ 0])
olditem =shoplist[ 0]
del shoplist[ 0]
print ('Я купил ', olditem)
print ('Теперь мой список покупок: ', shoplist)
Вывод:
$ python3 using_list.py
Я должен сделать 4 покупки.
Покупки: яблоки манго морковь бананы
Также нужно купить риса.
Теперь мой список покупок таков: ['яблоки', 'манго', 'морковь', 'бананы',
'рис']
Отсортирую-ка я свой список
Отсортированный список покупок выглядит так: ['бананы', 'манго', 'морковь',
'рис', 'яблоки']
(продолжениенаследующейстранице)
12.2. Краткое введение в объекты и классы 86A Byte of Python (Russian), Версия 2.02
(продолжениеспредыдущейстраницы)
Первое, что мне нужно купить, это бананы
Я купил бананы
Теперь мой список покупок: ['манго', 'морковь', 'рис', 'яблоки']
Как это работает:
Переменная shoplist – это список покупок человека, идущего на рынок. В
shoplist мы храним только строки с названиями того, что нужно купить,
однако в список можно добавлять любые объекты , включая числа или даже
другиесписки.
Мы также использовали цикл for..in для итерации по элементам списка.
Выуже,наверное,поняли,чтосписокявляетсятакжеипоследовательностью.
Особенностипоследовательностейбудутрассмотрены ниже.
Обратите внимание на использование ключевого аргумента endв функции
print,которыйпоказывает,чтомыхотимзакончитьвыводпробеломвместо
обычногопереводастроки.
Далеемыдобавляемэлементкспискуприпомощи append–методаобъекта
списка, который уже обсуждался ранее. Затем мы проверяем, действительно
ли элемент был добавлен к списку, выводя содержимое списка на экран при
помощи простой передачи этого списка функции print, которая аккуратно
егопечатает.
Затеммысортируемсписок,используяметод sortобъектасписка.Имейтев
виду,чтоэтотметоддействуетнасамсписок,аневозвращаетизменённуюего
версию. В этом отличие от того, как происходит работа со строками. Именно
этоимеетсяввиду,когдамыговорим,чтосписки изменяемы ,астроки– неиз-
меняемы.
Далеепослесовершенияпокупкимыхотимудалитьеёизсписка.Этодости-
гаетсяприменениемоператора del.Мыуказываем,какойэлементспискамы
хотимудалить,иоператор delудаляетего.Мыуказываем,чтохотимудалить
первыйэлементсписка,ипоэтомупишем« del shoplist[0] »(помните,что
Pythonначинаетотсчётс0).
Чтобыузнатьболеедетальнообовсехметодахобъектасписка,просмотрите help(list) .
12.2. Краткое введение в объекты и классы 87A Byte of Python (Russian), Версия 2.02
12.3
Кортеж
Кортежислужатдляхранениянесколькихобъектоввместе.Ихможнорассматриватькак
аналогсписков,нобезтакойобширнойфункциональности,которуюпредоставляеткласс
списка.Однаизважнейшихособенностейкортежейзаключаетсявтом,чтоони неизме-
няемы,также,какистроки.Т.е.модифицироватькортежиневозможно.
Кортежи обозначаются указанием элементов, разделённых запятыми; по желанию их
можноещёзаключитьвкруглыескобки.
Кортежиобычноиспользуютсявтехслучаях,когдаоператорилипользовательскаяфунк-
циядолжнынаверняказнать,чтонаборзначений,т.е.кортежзначений,неизменится.
Пример: (сохранитекак using_tuple.py )
zoo =('питон ','слон ','пингвин ')# помните, что скобки не обязательны
print ('Количество животных в зоопарке - ',len(zoo))
new_zoo ='обезьяна ','верблюд ', zoo
print ('Количество клеток в зоопарке - ',len(new_zoo))
print ('Все животные в новом зоопарке: ', new_zoo)
print ('Животные, привезённые из старого зоопарка: ', new_zoo[ 2])
print ('Последнее животное, привезённое из старого зоопарка - ', new_zoo[ 2][2])
print ('Количество животных в новом зоопарке - ',len(new_zoo) -1+\
len(new_zoo[ 2]))
Вывод:
$ python3 using_tuple.py
Количество животных в зоопарке - 3
Количество клеток в зоопарке - 3
Все животные в новом зоопарке: ('обезьяна', 'верблюд', ('питон', 'слон',
'пингвин'))
Животные, привезённые из старого зоопарка: ('питон', 'слон', 'пингвин')
Последнее животное, привезённое из старого зоопарка - пингвин
Количество животных в новом зоопарке - 5
Как это работает:
Переменная zooобозначает кортеж элементов. Как мы видим, функция len
позволяет получить длину кортежа. Это также указывает на то, что кортеж
является последовательностью .
Теперь мы перемещаем этих животных в новый зоопарк, поскольку старый
зоопарк закрывается. Поэтому кортеж new_zoo содержит тех животных, ко-
торые уже там, наряду с привезёнными из старого зоопарка. Возвращаясь к
реальности, обратите внимание на то, что кортеж внутри кортежа не теряет
своейиндивидуальности.
12.3. Кортеж 88A Byte of Python (Russian), Версия 2.02
Доступ к элементам кортежа осуществляется указанием позиции элемента,
заключённойвквадратныескобки–точнотакже,какмыэтоделалидляспис-
ков. Это называется оператором индексирования . Доступ к третьему элементу
вnew_zooмыполучаем,указывая new_zoo[2] ,адоступктретьемуэлементу
внутритретьегоэлементавкортеже new_zoo–указывая new_zoo[2][2] .Это
достаточнопросто,кактольковыпоймётепринцип.
Скобки
Хотя скобки и не являются обязательными, я предпочитаю всегда указывать их, чтобы
былоочевидно,чтоэтокортеж,особенновдвусмысленныхслучаях.Например, print(1,
2,3)иprint( (1,2,3) ) делаютразные вещи:первое выражение выводиттри числа,
тогдакаквторое–кортеж,содержащийэтитричисла.
Кортеж, содержащий 0 или 1 элемент
Пустой кортеж создаётся при помощи пустой пары скобок – « myempty = () ». Однако,
с кортежем из одного элемента не всё так просто. Его нужно указывать при помощи за-
пятой после первого (и единственного) элемента, чтобы Python мог отличить кортеж от
скобок, окружающих объект в выражении. Таким образом, чтобы получить кортеж, со-
держащийэлемент 2,вампотребуетсяуказать« singleton = (2,) ».
Замечание для программистов на Perl
Списоквнутрисписканетеряетсвоейиндивидуальности,т.е.спискинеразвёртываются,
каквPerl.Этожеотноситсяккортежувнутрикортежа,иликортежувнутрисписка,или
спискувнутрикортежаит.д.ВPythonвсеонирассматриваютсякакобъекты,хранящиеся
внутридругогообъекта–толькоивсего.
12.4
Словарь
Словарь–этонекийаналогадреснойкниги,вкоторойможнонайтиадресиликонтакт-
нуюинформациюочеловеке,знаялишьегоимя;т.е.некоторые ключи(имена)связаны
созначениями (информацией).Заметьте,чтоключдолженбытьуникальным–выведь
несможетеполучитькорректнуюинформацию,еслиувасзаписаныдвачеловекаспол-
ностьюодинаковымиименами.
Обратитетакжевниманиенато,чтовсловаряхвкачествеключеймогутиспользоваться
только неизменяемые объекты (как строки), а в качестве значений можно использовать
какнеизменяемые,такиизменяемыеобъекты.Точнееговоря,вкачествеключейдолжны
использоватьсятолькопростыеобъекты.
12.4. Словарь 89A Byte of Python (Russian), Версия 2.02
Пары ключ-значение указываются в словаре следующим образом: « d = {key1 :
value1, key2 : value2 } ». Обратите внимание, что ключ и значение разделяются
двоеточием, а пары друг от друга отделяются запятыми, а затем всё это заключается в
фигурныескобки.
Помните,чтопарыключ-значениеникоимобразомнеупорядоченывсловаре.Есливам
необходимнекоторыйпорядок,вампридётсяотдельноотсортироватьсловарьпередоб-
ращениемкнему.
Словариявляютсяэкземплярами/объектамикласса dict.
Пример: (сохранитекак using_dict.py )
# 'ab' - сокращение от 'a'ddress'b'ook
ab={'Swaroop ' :'swaroop@swaroopch.com ',
'Larry ' :'larry@wall.org ',
'Matsumoto ':'matz@ruby-lang.org ',
'Spammer ' :'spammer@hotmail.com '
}
print ("Адрес Swaroop 'а:", ab[ 'Swaroop '])
# Удаление пары ключ-значение
del ab['Spammer ']
print ('\nВ адресной книге {0} контакта \n'.format( len(ab)))
for name, address inab.items():
print ('Контакт {0} с адресом {1}'.format(name, address))
# Добавление пары ключ-значение
ab['Guido ']='guido@python.org '
if'Guido 'inab:
print ("\nАдрес Guido: ", ab[ 'Guido '])
Вывод:
$ python3 using_dict.py
Адрес Swaroop'а: swaroop@swaroopch.com
В адресной книге 3 контакта
Контакт Swaroop с адресом swaroop@swaroopch.com
Контакт Matsumoto с адресом matz@ruby-lang.org
Контакт Larry с адресом larry@wall.org
(продолжениенаследующейстранице)
12.4. Словарь 90A Byte of Python (Russian), Версия 2.02
(продолжениеспредыдущейстраницы)
Адрес Guido: guido@python.org
Как это работает:
Мы создаём словарь ab2при помощи обозначений, описанных ранее. Затем
мы обращаемся к парам ключ-значение, указывая ключ в операторе индек-
сирования, которым мы пользовались для списков и кортежей. Как видите,
синтаксиспрост.
Удалять пары ключ-значение можно при помощи нашего старого доброго
оператора del.Мыпростоуказываемимясловаряиоператориндексирования
дляудаляемогоключа,послечегопередаёмэтооператору del.Дляэтойопе-
рациинетнеобходимостизнать,какоезначениесоответствуетданномуклю-
чу.
Далеемыобращаемсяковсемпарамключ-значениенашегословаря,исполь-
зуя метод items, который возвращает список кортежей, каждый из которых
содержит пару элементов: ключ и значение. Мы получаем эту пару и при-
сваиваем её значение переменным nameиaddress соответственно в цикле
for..in,азатемвыводимэтизначениянаэкранвблокеfor.
Новые пары ключ-значение добавляются простым обращением к нужному
ключу при помощи оператора индексирования и присваиванием ему неко-
торогозначения,какмысделалидляGuidoвпримеревыше.
Проверить,существуетлипараключ-значение,можноприпомощиоператора
in.
Чтобыпросмотретьсписоквсехметодовкласса dictсмотрите help(dict) .
Ключевые Аргументы и Словари
Кслову,есливыиспользовалиключевыеаргументыввашихфункциях,выужеисполь-
зовали словари! Только подумайте: вы указали пару ключ-значение среди параметров
функции при её определении, а когда обращаетесь к переменным внутри функции, то
это,фактически,обращениепоключуксловарю(которыйвтерминахразработчиковком-
пиляторовназывается таблицей имён ).
2address book– англ.«адреснаякнига»( прим. перев. )
12.4. Словарь 91A Byte of Python (Russian), Версия 2.02
12.5
Последовательности
Списки, кортежи и строки являются примерами последовательностей. Но что такое по-
следовательностиичтовнихтакогоособенного?
Основные возможности – это проверка принадлежности (т.е. выражения « in» и « not
in») и оператор индексирования , позволяющий получить напрямую некоторый эле-
ментпоследовательности.
Все три типа последовательностей, упоминавшиеся выше (списки, кортежи и строки),
такжепредоставляютоперациюполучения вырезки,котораяпозволяетполучитьвырез-
купоследовательности,т.е.еёфрагмент.
Пример: (сохранитекак seq.py)
shoplist =['яблоки ','манго ','морковь ','бананы ']
name ='swaroop '
# Операция индексирования
print ('Элемент 0 - ', shoplist[ 0])
print ('Элемент 1 - ', shoplist[ 1])
print ('Элемент 2 - ', shoplist[ 2])
print ('Элемент 3 - ', shoplist[ 3])
print ('Элемент -1 - ', shoplist[ -1])
print ('Элемент -2 - ', shoplist[ -2])
print ('Символ 0 - ', name[ 0])
# Вырезка из списка
print ('Элементы с 1 по 3: ', shoplist[ 1:3])
print ('Элементы с 2 до конца: ', shoplist[ 2:])
print ('Элементы с 1 по -1: ', shoplist[ 1:-1])
print ('Элементы от начала до конца: ', shoplist[:])
# Вырезка из строки
print ('Символы с 1 по 3: ', name[ 1:3])
print ('Символы с 2 до конца: ', name[ 2:])
print ('Символы с 1 до -1: ', name[ 1:-1])
print ('Символы от начала до конца: ', name[:])
Вывод:
$ python3 seq.py
Элемент 0 - яблоки
Элемент 1 - манго
Элемент 2 - морковь
Элемент 3 - бананы
Элемент -1 - бананы
(продолжениенаследующейстранице)
12.5. Последовательности 92A Byte of Python (Russian), Версия 2.02
(продолжениеспредыдущейстраницы)
Элемент -2 - морковь
Символ 0 - s
Элементы с 1 по 3: ['манго', 'морковь']
Элементы с 2 до конца: ['морковь', 'бананы']
Элементы с 1 по -1: ['манго', 'морковь']
Элементы от начала до конца: ['яблоки', 'манго', 'морковь', 'бананы']
Символы с 1 по 3: wa
Символы с 2 до конца: aroop
Символы с 1 до -1: waroo
Символы от начала до конца: swaroop
Как это работает:
Преждевсего,мывидим,какиспользоватьиндексыдляполученияотдельных
элементовпоследовательности.Этоещёназывают приписыванием индекса .Ко-
гдамыуказываемчисловквадратныхскобкахпослепоследовательности,как
показановыше,Pythonизвлекаетэлемент,соответствующийуказаннойпози-
циивпоследовательности.Помните,чтоPythonначинаетотсчётс0.Поэтому
shoplist[0] извлекаетпервыйэлемент,а shoplist[3] –четвёртыйэлемент
последовательности shoplist .
Индекстакжеможетбытьотрицательнымчислом.Вэтомслучаепозицияот-
считываетсяотконцапоследовательности.Поэтому shoplist[-1] указывает
на последний элемент последовательности shoplist , аshoplist[-2] – на
предпоследний.
Операция вырезки производится при помощи указания имени последова-
тельности,закоторымможетследоватьпарачисел,разделённыхдвоеточием
и заключённых в квадратные скобки. Заметьте, как это похоже на операцию
индексирования,котороймыпользовалисьдосихпор.Помните,чточислав
скобкахнеобязательны,тогдакакдвоеточие–обязательно.
Первое число (перед двоеточием) в операции вырезки указывает позицию, с
которойвырезкадолжнаначинаться,автороечисло(последвоеточия)указы-
вает, где вырезка должна закончиться. Если первое число не указано, Python
начнётвырезкусначалапоследовательности.Еслипропущеновтороечисло,
Python закончит вырезку у конца последовательности. Обратите внимание,
что полученная вырезка будет начинаться с указанной начальной позиции,
азаканчиваться прямо перед указанной конечной позицией, т.е. начальная
позициябудетвключенаввырезку,аконечная–нет.
Такимобразом, shoplist[1:3] возвращаетвырезкуизпоследовательности,
начинающуюся с позиции 1, включает позицию 2, но останавливается на
позиции 3, и поэтому возвращает вырезкуиз двух элементов. Аналогично,
shoplist[:] возвращаеткопиювсейпоследовательности.
Вырезка может осуществляться и с отрицательными значениями. Отрица-
12.5. Последовательности 93A Byte of Python (Russian), Версия 2.02
тельныечислаобозначаютпозициюсконцапоследовательности.Например,
shoplist[:-1] вернёт вырезку из последовательности, исключающую по-
следнийэлемент,носодержащуювсеостальные.
Крометого,можнотакжеуказатьтретийаргументдлявырезки,которыйбудет
обозначать шагвырезки(поумолчаниюшагвырезкиравен1):
>>> shoplist =['яблоки ','манго ','морковь ','бананы ']
>>> shoplist[:: 1]
['яблоки', 'манго', 'морковь', 'бананы']
>>> shoplist[:: 2]
['яблоки', 'морковь']
>>> shoplist[:: 3]
['яблоки', 'бананы']
>>> shoplist[:: -1]
['бананы', 'морковь', 'манго', 'яблоки']
Обратитевниманиенато,чтокогдашагравен2,мыполучаемэлементы,на-
ходящиеся на позициях 0, 2, … Когда шаг равен 3, мы получаем элементы с
позиций0,3,…ит.д.
Попробуйтеразныекомбинациипараметроввырезки,используяинтерактивнуюоболоч-
ку интерпретатора Python, т.е. его командную строку, чтобы сразу видеть результат. По-
следовательностизамечательнытем,чтоонидаютвозможностьобращатьсяккортежам,
спискамистрокамоднимитемжеспособом!
12.6
Множество
Множества–это неупорядоченные наборыпростыхобъектов.Онинеобходимытогда,ко-
гда присутствие объекта в наборе важнее порядка или того, сколько раз данный объект
тамвстречается.
Используя множества, можно осуществлять проверку принадлежности, определять, яв-
ляется ли данное множество подмножеством другого множества, находить пересечения
множествитакдалее.
>>> bri =set(['Бразилия ','Россия ','Индия '])
>>> 'Индия 'inbri
True
>>> 'США'inbri
False
>>> bric =bri.copy()
>>> bric .add( 'Китай ')
>>> bric .issuperset(bri)
True
(продолжениенаследующейстранице)
12.6. Множество 94A Byte of Python (Russian), Версия 2.02
(продолжениеспредыдущейстраницы)
>>> bri.remove( 'Россия ')
>>> bri &bric # OR bri.intersection(bric)
{'Бразилия', 'Индия'}
Как это работает:
Этот пример достаточно нагляден, так как использует основы теории мно-
жествизшкольногокурсаматематики.
12.7
Ссылки
Когда мы создаём объект и присваиваем его переменной, переменная только ссылается
на объект, а не представляет собой этот объект! То есть имя переменной указывает на
ту часть памяти компьютера, где хранится объект. Это называется привязкой имени к
объекту.
Обычно вам не следует об этом беспокоиться, однако есть некоторый неочевидный эф-
фект,окоторомнужнопомнить:
Пример: (сохранитекак reference.py )
print ('Простое присваивание ')
shoplist =['яблоки ','манго ','морковь ','бананы ']
mylist =shoplist # mylist - лишь ещё одно имя, указывающее на тот же объект!
del shoplist[ 0]# Я сделал первую покупку, поэтому удаляю её из списка
print ('shoplist: ', shoplist)
print ('mylist: ', mylist)
# Обратите внимание, что и shoplist, и mylist выводят один и тот же список
# без пункта "яблоко", подтверждая тем самым, что они указывают на один
# объект.
print ('Копирование при помощи полной вырезки ')
mylist =shoplist[:] # создаём копию путём полной вырезки
del mylist[ 0]# удаляем первый элемент
print ('shoplist: ', shoplist)
print ('mylist: ', mylist)
# Обратите внимание, что теперь списки разные
Вывод:
12.7. Ссылки 95A Byte of Python (Russian), Версия 2.02
$ python3 reference.py
Простое присваивание
shoplist: ['манго', 'морковь', 'бананы']
mylist: ['манго', 'морковь', 'бананы']
Копирование при помощи полной вырезки
shoplist: ['манго', 'морковь', 'бананы']
mylist: ['морковь', 'бананы']
Как это работает:
Большаячастьобъяснениясодержитсявкомментариях.
Помните, что если вам нужно сделать копию списка или подобной последо-
вательности, или другого сложного объекта (не такого простого объекта, как
целое число), вам следует воспользоваться операцией вырезки. Если вы про-
сто присвоите имя переменной другому имени, оба они будут ссылаться на
одинитотжеобъект,аэтоможетпривестикпроблемам,есливынеосторож-
ны.
12.8
Ещё о строках
Мы уже детально обсуждали строки ранее. Что же ещё можно о них узнать? Что ж, вы
знали, например, что строки также являются объектами и имеют методы, при помощи
которых можно делать практически всё: от проверки части строки до удаления краевых
пробелов?
Всестроки,используемыевамивпрограммах,являютсяобъектамикласса str.Некоторые
полезныеметодыэтогоклассапродемонстрированынапримерениже.Чтобыпосмотреть
весьсписокметодов,выполните help(str) .
Пример: (сохранитекак str_methods.py )
name ='Swaroop '# Это объект строки
ifname .startswith( 'Swa'):
print ('Да, строка начинается на "Swa"')
if'a'inname:
print ('Да, она содержит строку "a"')
ifname .find( 'war')!=-1:
print ('Да, она содержит строку "war"')
delimiter ='_*_'
(продолжениенаследующейстранице)
12.8. Ещё о строках 96A Byte of Python (Russian), Версия 2.02
(продолжениеспредыдущейстраницы)
mylist =['Бразилия ','Россия ','Индия ','Китай ']
print (delimiter .join(mylist))
Вывод:
$ python3 str_methods.py
Да, строка начинается на "Swa"
Да, она содержит строку "a"
Да, она содержит строку "war"
Бразилия_*_Россия_*_Индия_*_Китай
Как это работает:
Здесь мы видим сразу несколько методов строк в действии. Метод startswith служит
длятого,чтобыопределять,начинаетсялистрокаснекоторойзаданнойподстроки.Опе-
ратор inиспользуетсядляпроверки,являетсялинекотораястрокачастьюданнойстроки.
Метод findиспользуетсядляопределенияпозицииданнойподстрокивстроке; findвоз-
вращает-1, если подстрока не обнаружена. В классе strтакжеимеется отличный метод
дляобъединения( join)3элементовпоследовательностисуказаннойстрокойвкачестве
разделителя между элементами, возвращающий большую строку, сгенерированную та-
кимобразом.
12.9
Резюме
Мы детально рассмотрели различные встроенные структуры данных Python. Эти струк-
турыданныхбудуткрайневажныдлянаписанияпрограммсущественногоразмера.
Теперь, когда мы накопили достаточно базовых знаний о Python, далее посмотрим, как
проектироватьиписатьнастоящуюпрограммунаPython.
3join– англ.«объединять»( прим.перев. )
12.9. Резюме 97Решение задач
МырассмотрелиразличныечастиязыкаPython,итеперьпосмотрим,каквсеэтичастира-
ботаютвместе,проектируяисоставляяпрограмму,которая делаетчто-тополезное.Цель
состоитвтом,чтобынаучитьсяписатьсценариинаязыкеPythonсамостоятельно.
13.1
Задача
Перед нами стоит следующая задача: Составить программу, которая создаёт резервные
копии всех наших важных файлов .
Хотязадачаипроста,информацииявнонедостаточно,чтобыприступатькеёрешению.
Необходимнекоторыйдополнительный анализ.Например,какмывыберем, какиефай-
лынеобходимокопировать? Какиххранить? Гдеиххранить?
Посленадлежащегоанализамы проектируем нашупрограмму.Мысоздаёмсписок,опи-
сывающий то, как наша программа должна работать. В данном случае я создал список
того,как ясебепредставляюеёработу.Когдавыпроектируетепрограмму,увасможетпо-
лучитьсядругойрезультат,посколькукаждыйчеловекпредставляетсебеэтопо-своему,
такчтоэтовпорядкевещей.
1.Файлыикаталоги,которыенеобходимоскопировать,собираютсявсписок.
2.Резервныекопиидолжныхранитьсявосновномкаталогерезерва.
3.Файлыпомещаютсявzip-архив.
4.Именемдляzip-архиваслужиттекущаядатаивремя.
5.Будемиспользоватьстандартнуюкоманду zip,имеющуюсяпоумолчаниювлюбом
стандартномдистрибутивеGNU/Linux.ПользователиWindowsмогут установить её
состраницыпроектаGnuWin32 идобавить« C:\Program Files\GnuWin32\bin »к
системной переменной окружения PATH, аналогично тому, как мы это делалидля
самойкоманды«python».Обратитевнимание,чтодляэтогоподойдётлюбаякоман-
даархивации,еслиунеёестьинтерфейскоманднойстроки,чтобыейможнобыло
передаватьаргументыизнашегосценария.
98A Byte of Python (Russian), Версия 2.02
13.2
Решение
Кактолькопроектпрограммыболее-менееустоялся,можноприступатькнаписаниюко-
да,которыйибудетявляться реализацией нашегорешения.
Сохранитекак backup_ver1.py :
import os
import time
# 1. Файлы и каталоги, которые необходимо скопировать, собираются в список.
source =['"C:\\My Documents "','C:\\Code ']
# Заметьте, что для имён, содержащих пробелы, необходимо использовать
# двойные кавычки внутри строки.
# 2. Резервные копии должны храниться в основном каталоге резерва.
target_dir ='E:\\Backup '# Подставьте ваш путь.
# 3. Файлы помещаются в zip-архив.
# 4. Именем для zip-архива служит текущая дата и время.
target =target_dir +os.sep +time .strftime( '%Y%m%d%H%M%S')+'.zip '
# 5. Используем команду "zip" для помещения файлов в zip-архив
zip_command ="zip -qr {0} {1}".format(target, ''.join(source))
# Запускаем создание резервной копии
ifos.system(zip_command) ==0:
print ('Резервная копия успешно создана в ', target)
else :
print ('Создание резервной копии НЕ УДАЛОСЬ ')
Вывод:
$ python3 backup_ver1.py
Резервная копия успешно создана в E:\\Backup\\20080702185040.zip
Теперьнаступаетстадия тестирования ,когдамыпроверяем,правильнолиработаетнаша
программа.Еслионаработаетнетак,какожидалось,нампридётсязанятьсяеё отладкой
(дебагом)1,т.е.устранением багов(ошибок)впрограмме.
Еслиприведённаявышепрограммауваснезаработает,допишите print(zip_command)
прямо перед вызовом os.system и запустите программу. После этого скопируйте вы-
1debug–применительноккомпьютернымпрограммамобозначает отладку(обнаружениеиустранение
ошибок,которыеприэтомпринятоназывать«bug»,т.е.«жук»).Повсейвидимости,это берётсвоёначало
с процедуры изгнания насекомых из схем больших ЭВМ, хотя само понятие «bug» в смысле маленькой
неисправности встречается и в более ранней литературе, например, в записях Томаса Эдисона 1878 года.
(прим. перев. )
13.2. Решение 99A Byte of Python (Russian), Версия 2.02
веденную команду «zip_command» и вставьте её в командную строку, чтобы проверить,
работает ли она корректно сама по себе. Если она не срабатывает, проверьте справку по
команде«zip»,чтобывыяснить,вчёмможетбытьпроблема.Есликомандауспешновы-
полняется,проверьте,совпадаетливашапрограмманаPythonвточностиспрограммой,
приведённойвыше.
Как это работает:
Вызаметили,какмыпревратилинаш проектвкодшагзашагом.
Мыиспользовалимодули osиtime,предварительноимпортировавих.Далее
мыуказалифайлыикаталогидлярезервногокопированиявсписке source2.
Каталогназначения–этокаталог,вкотороммысохраняемвсерезервныеко-
пии, и он указывается в переменной target_dir . Именем zip-архива, кото-
рыймысоздаём,будеттекущаядатаивремя,которыегенерируютсяприпо-
мощифункции time.strftime() .Унегобудетрасширение .zip,ихранить-
сяонбудетвкаталоге target_dir .
Обратитевниманиенаупотреблениепеременной os.sep–онасодержитраз-
делитель пути для конкретной операционной системы, т.е. он будет '/'в
GNU/Linux и Unix3,'\\'в Windows и ':'в Mac OS. Использование os.sep
вместо этих символов напрямую делает программу переносимой, и она смо-
жетработатьнавсехэтихоперационныхсистемах.
Функция time.strftime() принимает в качестве аргумента формат вывода
времени,например,такой,какмыуказаливпрограммевыше.Символформа-
та%Yбудетзамещёнгодомистолетием.Символ %mбудетзамещёнмесяцемв
формечислаот 01до12,итакдалее.Полныйсписоктакихсимволовформата
можнонайтив справочникепоPython .
Имяконечногоzip-файламысоздаёмприпомощиоператора,который соеди-
няетстроки,т.е.объединяетдвестрокиивозвращаетновую.Послеэтогомы
создаём строку zip_command , которая содержит команду, которую мы наме-
ренывыполнить.Проверить,работаетлиэтакоманда,можнозапустивеёот-
дельно в командной оболочке (терминал в GNU/Linux или командная строка
DOS).
Команда zip,которуюмыиспользуем,имеетнекоторыепараметры.Параметр
«-q» используется для указания, что команда должна сработать тихо4. Пара-
метр « -r» обозначает, что команда архивации должна работать рекурсивно5
для каталогов, т.е. должна включать все подкаталоги и файлы. Оба парамет-
ра объединены и указаны в краткой форме « -qr». За параметрами следует
2source– англ.«источник»( прим.перев. )
3Под словом «Unix» здесь подразумеваются все операционные системы, построенные по принципам
ОСUnix,анетолькоонасамапосебе.Примерамитакихоперационныхсистемявляютсявседистрибутивы
GNU/Linux,семействоОС*BSD,Android,Solarisит.д.( прим.перев. )
4quietly– англ.«тихо»( прим.перев. )
5recursive– англ.«рекурсивно»( прим.перев. )
13.2. Решение 100A Byte of Python (Russian), Версия 2.02
имя создаваемого zip-архива, за которым указывается список файлов и ката-
логовдлярезервногокопирования.Мыпревращаемсписок sourceвстроку,
используяужезнакомыйнамметод join.
Затеммы,наконец, выполняем командуприпомощифункции os.system ,ко-
тораязапускаеткомандутак,какбудтоонабылазапущенаиз системы,т.е.из
команднойоболочки.Онавозвращает 0,есликомандавыполненауспешно,в
противномслучаеонавозвращаеткодошибки.
Взависимостиотвыводакоманды,мыпечатаемсоответствующеесообщение
отом,успешнымбылосозданиерезервныхкопийилинет.
Вотивсё,мысоздалисценарийдлясохранениярезервныхкопийнашихваж-
ныхфайлов!
Замечание для пользователей Windows
Вместо управляющей последовательности для обратной наклонной черты могут ис-
пользоваться«сырые»6строки.Например,можнописать« C:\\Documents »или« r'C:\
Documents' ».Однако, неиспользуйте« 'C:\Documents' »,таккаквэтомслучаеокажет-
ся,чтовыпытаетесьприменитьнеизвестнуюуправляющуюпоследовательность \D.
Теперь,когдаунасестьрабочийсценарийрезервногокопирования,мыможемиспользо-
ватьегодлясозданиякопийнашихфайлов.ПользователямGNU/LinuxиUnixрекоменду-
ется сделать этот программный файл исполнимым , чтобы иметь возможность запускать
еговлюбоевремяизлюбогоместа.Этоназывается операционной фазойили развёрты-
ваниемпрограммы.
Программа,приведённаявыше,работаеткорректно,но(обычно)поначалупрограммыне
работают так, как вы того ожидаете. Проблемы могут возникать вследствие неправиль-
ногопроектированияпрограммы,допущенияошибкипринаборепрограммногокодаи
т.д.Втакихслучаяхприходитсявозвращатьсякстадиипроектированияилиотладкипро-
граммы.
13.3
Вторая версия
Перваяверсиянашегосценарияработает.Темнеменее,егоможноулучшитьтак,чтобы
было удобнее пользоваться в повседневной работе. Это называется стадией поддержки
программы.
Одноизулучшений,показавшеесямнеполезным,–этолучшиймеханизмименования
файлов:использование временивкачествеименифайла,сохраняющегосявкаталогсте-
кущейдатойвкачествеимени,которыйвсвоюочередь,расположенвглавномкаталоге
6raw– англ.«сырой»,«необработанный»( прим.перев )
13.3. Вторая версия 101A Byte of Python (Russian), Версия 2.02
дляхранениярезервныхкопий.Первоедостоинствоэтогосостоитвтом,чтокопиихра-
нятся в иерархической структуре, которой легче управлять. Второе достоинство – в том,
чтоименафайловнамногокороче.Третьедостоинствосостоитвтом,чтопоименамката-
логовможнолегкоопределить,вкакиеднисоздавалисьрезервныекопии,таккаккаталог
создаётсятольковслучаерезервногокопированияданныхвэтотдень.
Сохранитекак backup_ver2.py :
import os
import time
# 1. Файлы и каталоги, которые необходимо скопировать, собираются в список.
source =['"C:\\My Documents "','C:\\Code ']
# Заметьте, что для имён, содержащих пробелы, необходимо использовать
# двойные кавычки внутри строки.
# 2. Резервные копии должны храниться в основном каталоге резерва.
target_dir ='E:\\Backup '# Подставьте ваш путь.
# 3. Файлы помещаются в zip-архив.
# 4. Текущая дата служит именем подкаталога в основном каталоге
today =target_dir +os.sep +time .strftime( '%Y%m%d')
# Текущее время служит именем zip-архива
now =time .strftime( '%H%M%S')
# Создаём каталог, если его ещё нет
ifnot os.path .exists(today):
os.mkdir(today) # создание каталога
print ('Каталог успешно создан ', today)
# Имя zip-файла
target =today +os.sep +now +'.zip '
# 5. Используем команду "zip" для помещения файлов в zip-архив
zip_command ="zip -qr {0} {1}".format(target, ''.join(source))
# Запускаем создание резервной копии
ifos.system(zip_command) ==0:
print ('Резервная копия успешно создана в ', target)
else :
print ('Создание резервной копии НЕ УДАЛОСЬ ')
Вывод:
$ python3 backup_ver2.py
Каталог успешно создан E:\\Backup\\20080702
Резервная копия успешно создана в E:\\Backup\\20080702\\202311.zip
(продолжениенаследующейстранице)
13.3. Вторая версия 102A Byte of Python (Russian), Версия 2.02
(продолжениеспредыдущейстраницы)
$ python3 backup_ver2.py
Резервная копия успешно создана в E:\\Backup\\20080702\\202325.zip
Как это работает:
Большая часть программы осталась прежней. Разница в том, что теперь мы
проверяем,существуетликаталогсименем,соответствующемтекущейдате,
внутри главного каталога для хранения резервных копий. Для этого мы ис-
пользуемфункцию os.path.exists .Еслионнесуществует,мысоздаёмего
функцией os.mkdir .
13.4
Третья версия
Втораяверсияужеудобнеедляработысбольшимколичествомрезервныхкопий.Сдру-
гойстороны,когдаихмного,становитсятрудноотличить,какаякопиядлячего.Напри-
мер,мымогливнестизначительныеизменениявкакую-топрограммуилипрезентацию,
итеперьхотимуказатьсутьэтихизмененийвимениzip-архива.Этоголегкоможнодо-
стичьдобавлениемпользовательскогокомментариякимениzip-архива.
Примечание: Следующая программа не работает, так что не переживайте, просто про-
следуйтепоней,таккаквнейсодержитсяурок.
Сохранитекак backup_ver3.py
import os
import time
# 1. Файлы и каталоги, которые необходимо скопировать, собираются в список.
source =['"C:\\My Documents "','C:\\Code ']
# Заметьте, что для имён, содержащих пробелы, необходимо использовать
# двойные кавычки внутри строки.
# 2. Резервные копии должны храниться в основном каталоге резерва.
target_dir ='E:\\Backup '# Подставьте ваш путь.
# 3. Файлы помещаются в zip-архив.
# 4. Текущая дата служит именем подкаталога в основном каталоге
today =target_dir +os.sep +time .strftime( '%Y%m%d')
# Текущее время служит именем zip-архива
now =time .strftime( '%H%M%S')
(продолжениенаследующейстранице)
13.4. Третья версия 103A Byte of Python (Russian), Версия 2.02
(продолжениеспредыдущейстраницы)
# Запрашиваем комментарий пользователя для имени файла
comment =input ('Введите комментарий --> ')
iflen(comment) ==0:# проверяем, введён ли комментарий
target =today +os.sep +now +'.zip '
else :
target =today +os.sep +now +'_'+
comment .replace( '','_')+'.zip '
# Создаём каталог, если его ещё нет
ifnot os.path .exists(today):
os.mkdir(today) # создание каталога
print ('Каталог успешно создан ', today)
# 5. Используем команду "zip" для помещения файлов в zip-архив
zip_command ="zip -qr {0} {1}".format(target, ''.join(source))
# Запускаем создание резервной копии
ifos.system(zip_command) ==0:
print ('Резервная копия успешно создана в ', target)
else :
print ('Создание резервной копии НЕ УДАЛОСЬ ')
Вывод:
$ python3 backup_ver3.py
File "backup_ver3.py", line 25
target = today + os.sep + now + '_' +
^
SyntaxError: invalid syntax
Как это (не) работает:
Эта программа не работает! Python сообщает об обнаружении ошибки син-
таксиса,чтоозначает,чтосценарийнеудовлетворяетструктуре,которуюожи-
даетувидетьPython.КогдаPythonвыдаётсообщениеобошибке,онтакжеука-
зываетнамнаместоошибки.Такчтомыначинаем отладкупрограммысэтой
строки.
Привнимательномрассмотрении,мывидим,чтоодналогическаястрокабы-
ла разбита на две физические строки, но мы не указали, что эти две физи-
ческие строки являются частью одной. На деле же Python просто обнаружил
оператор сложения ( +) без соответствующего операнда в той же логической
строке,апоэтомунезнает,какпродолжать.Помните,чтомыможемуказать,
чтологическаястрокапродолжаетсянаследующейфизическойприпомощи
обратной наклонной черты в конце физической строки. Внесём это исправ-
лениевнашупрограмму.Коррекцияпрограммыприобнаруженииошибоки
13.4. Третья версия 104A Byte of Python (Russian), Версия 2.02
называется отладкой7.
13.5
Четвёртая версия
Сохранитекак backup_ver4.py
import os
import time
# 1. Файлы и каталоги, которые необходимо скопировать, собираются в список.
source =['"C:\\My Documents "','C:\\Code ']
# Заметьте, что для имён, содержащих пробелы, необходимо использовать
# двойные кавычки внутри строки.
# 2. Резервные копии должны храниться в основном каталоге резерва.
target_dir ='E:\\Backup '# Подставьте ваш путь.
# 3. Файлы помещаются в zip-архив.
# 4. Текущая дата служит именем подкаталога в основном каталоге
today =target_dir +os.sep +time .strftime( '%Y%m%d')
# Текущее время служит именем zip-архива
now =time .strftime( '%H%M%S')
# Запрашиваем комментарий пользователя для имени файла
comment =input ('Введите комментарий --> ')
iflen(comment) ==0:# проверяем, введён ли комментарий
target =today +os.sep +now +'.zip '
else :
target =today +os.sep +now +'_'+\
comment .replace( '','_')+'.zip '
# Создаём каталог, если его ещё нет
ifnot os.path .exists(today):
os.mkdir(today) # создание каталога
print ('Каталог успешно создан ', today)
# 5. Используем команду "zip" для помещения файлов в zip-архив
zip_command ="zip -qr {0} {1}".format(target, ''.join(source))
# Запускаем создание резервной копии
ifos.system(zip_command) ==0:
print ('Резервная копия успешно создана в ', target)
else :
print ('Создание резервной копии НЕ УДАЛОСЬ ')
7bugfixing–устранение«багов»,исправлениеошибок( прим.перев )
13.5. Четвёртая версия 105A Byte of Python (Russian), Версия 2.02
Вывод:
$ python3 backup_ver4.py
Введите комментарий --> added new examples
Резервная копия успешно создана в E:\Backup\20080702\202836_added_new_
,→examples.zip
$ python3 backup_ver4.py
Введите комментарий -->
Резервная копия успешно создана в E:\Backup\20080702\202839.zip
Как это работает:
Теперьэтапрограммаработает!Давайтепросмотримвсеулучшения,сделан-
ныенамидляверсии3.Мызапрашиваемпользовательскийкомментарийпри
помощи функции input, а затем проверяем, ввёл ли пользователь что-либо,
определяядлинувведённойстрокифункцией len.Еслипользовательпросто
нажал ENTER,невводяникакоготекста(можетбыть,этобылорегулярноесо-
здание резервной копии, или никаких особых изменений внесено не было),
мыпродолжаемтакже,какделалидосихпор.
Если же комментарий был введён, он добавляется к имени zip-архива перед
расширением .zip.Обратитевнимание,чтомызаменяемпробелывкоммен-
тарииподчёркиваниями:управлятьфайламибезпробеловвименахнамного
легче.
13.6
Дополнительные усовершенствования
Четвёртая версия – вполне удовлетворительный рабочий сценарий для большинства
пользователей,однаконетпределовсовершенства.Например,впрограммуможнодоба-
витьуровень подробности8вывода,чтобыприуказаниипараметра« -v»онастановилась
более«разговорчивой».
Ещёоднимвозможнымулучшениембылабывозможностьпередаватьсценариюдругие
файлыикаталогипрямовкоманднойстроке.Этиименаможнополучатьизсписка sys.
argvидобавлятькнашемусписку sourceприпомощиметода extendкласса list.
Наиболее важным усовершенствованием было бы прекращение использования os.
systemдля создания архивов, а применение вместо него встроенных модулей zipfile
илиtarfile. Они являются частью стандартной библиотеки, поэтому всегда доступны
дляиспользованиябеззависимостиотвнешнейпрограммыzipнакомпьютере.
8verbosity– англ.«многословность».Применительноккомпьютернымпрограммамобозначаетстепень
подробности выводимых программой сообщений, т.е. степень «разговорчивости» программы. Отсюда и
названиеэтогопараметра( прим.перев )
13.6. Дополнительные усовершенствования 106A Byte of Python (Russian), Версия 2.02
Вприведённыхпримерахмыиспользовалиспособс os.system длясозданиярезервных
копийисключительновпедагогическихцелях,чтобыпримербылдостаточнопростдля
пониманиялюбымчитателем,нодостаточнореалендлятого,чтобыделатьчто-тополез-
ное.
Попробуйте написать пятую версию с использованием модуля zipfileвместо вызова os.
system.
13.7
Процесс разработки программного обеспече-
ния
Впроцессесозданияпрограммымыпрошличерезнесколько стадий.Этистадииможно
свестипримерновтакойсписок:
•Что(Анализ)
•Как(Проектирование)
•Создание(Реализация)
•Тестирование(ТестированиеиОтладка)
•Использование(РазвёртываниеиОперирование)
•Поддержка(Усовершенствование)
Процедура,которуюмыпрошлипринаписаниисценариясозданиярезервныхкопийре-
комендуется и для других программ: Проведите анализ и проектирование. Начните ре-
ализацию с простейшей версии. Протестируйте и отладьте её. Попользуйтесь ею, чтобы
убедиться,чтоонаработает,какожидалось.Послеэтогодобавляйтелюбыенеобходимые
функции,повторяяцикл«Создание-Тестирование-Использование»столькораз,сколько
потребуется.Помните, Программы выращиваются, а не строятся .
13.8
Резюме
Мы увидели, как создавать свои собственные программы/сценарии на Python, а также
различныестадиинаписанияпрограмм.Наданномэтапевамбудетполезносоздатьсоб-
ственную программу по такому рецепту, как мы это делали в настоящей главе, чтобы
лучшепривыкнутькPython,равнокакикрешениюзадач.
Далеемыобсудимобъектно-ориентированноепрограммирование.
13.7. Процесс разработки программного обеспечения 107Объектно-ориентированное
программирование
Досихпорнашипрограммысостоялиизфункций,т.е.блоковвыражений,которыемани-
пулируютданными.Этоназывается процедурно-ориентированным стилемпрограммиро-
вания.Существуетидругойспособорганизациипрограмм:объединятьданныеифунк-
ционал внутри некоего объекта. Это называется объектно-ориентированной парадигмой
программирования.Вбольшинствеслучаевможноограничитьсяпроцедурнымпрограм-
мированием,апринаписаниибольшойпрограммыилиеслирешениеконкретнойзада-
читоготребует,можнопереходитьктехникамобъектно-ориентированногопрограмми-
рования.
Два основных аспекта объектно-ориентированного программирования – классы и объ-
екты. Класссоздаёт новый тип, аобъекты являются экземплярами класса. Аналогично,
когдамыговоримо«переменныхтипа int»,этоозначает,чтопеременные,которыехра-
нятцелочисленныезначения,являютсяэкземплярами(объектами)класса int.
Замечание для программистов на статических языках
Обратите внимание, что даже целые числа рассматриваются как объекты (класса int),
в отличие от C++ и Java (до версии 1.5), где целые числа являются примитивами. См.
help(int) для более детального описания этого класса. Программисты на C# и Java 1.5
могутзаметитьсходствосконцепцией упаковки и распаковки1.
Объекты могут хранить данные в обычных переменных, которые принадлежат объек-
ту.Переменные,принадлежащиеобъектуиликлассу,называют полями.Объектымогут
также обладать функционалом, т.е. иметь функции, принадлежащие классу. Такие функ-
циипринятоназывать методами класса.Этатерминологияважна,таккаконапомогает
нам отличать независимые функции и переменные от тех, что принадлежат классу или
объекту.Всёвместе(поляиметоды)принятоназывать атрибутами класса.
Полябываютдвухтипов:онимогутпринадлежатькаждомуотдельномуэкземпляруобъ-
екта класса или всему классу. Они называются переменными экземпляра иперемен-
ными класса соответственно.
1boxingandunboxing
108A Byte of Python (Russian), Версия 2.02
Класс создаётся ключевым словом class. Поля и методы класса записываются в блоке
кодасотступом.
14.1
self
Методыклассаимеютодноотличиеотобычныхфункций:онидолжныиметьдополни-
тельноимя,добавляемоекначалуспискапараметров.Однако,привызовеметоданикако-
гозначенияэтомупараметруприсваивать ненужно–егоукажетPython.Этапеременная
указываетна самобъектэкземпляракласса,ипотрадициионаназывается self2.
Хотяэтомупараметруможнодатьлюбоеимя, настоятельно рекомендуется использовать
толькоимя self;использованиелюбогодругогоименинеприветствуется.Естьмногодо-
стоинствиспользованиястандартногоимени:во-первых,любойчеловек,просматриваю-
щийвашупрограмму,легкоузнаетего;во-вторых,некоторыеспециализированныеИн-
тегрированныесредыразработки(IDE)изначальнорассчитанынаиспользование self.
Замечание для программистов на C++, Java и C#
selfвPythonэквивалентноуказателю thisвC++иссылке thisвJavaиC#.
Вы, должно быть, удивляетесь, как Python присваивает значение selfи почему вам не
нужноуказыватьэтозначениесамостоятельно.Пояснимэтонапримере.Предположим,
у нас есть класс с именем MyClass и экземпляр этого класса с именем myobject . При
вызове метода этого объекта, например, « myobject.method(arg1, arg2) », Python ав-
томатическипревращаетэтов« MyClass.method(myobject, arg1, arg2) »–вэтоми
состоитсмысл self.
Этотакжеозначает,чтоесликакой-либометоднепринимаетаргументов,унеговсёравно
будетодинаргумент– self.
14.2
Классы
Простейшийкласспоказанвследующемпримере(сохранитекак simplestclass.py ).
class Person :
pass # Пустой блок
p=Person()
print (p)
Вывод:
2self– англ.«сам»( прим.перев. )
14.1. self 109A Byte of Python (Russian), Версия 2.02
$ python3 simplestclass.py
<__main__.Person object at 0x019F85F0>
Как это работает:
Мы создаём новый класс при помощи оператора classи имени класса. За
этим следует блок выражений, формирующих тело класса. В данном случае
блокунаспуст,начтоуказываетоператор pass.
Далеемысоздаёмобъект-экземпляркласса,записываяимяклассасоскобка-
ми.(Мыузнаембольшео реализации вследующемразделе).Дляпроверкимы
выясняем тип переменной, просто выводя её на экран. Так мы видим, что у
насестьэкземпляркласса Personвмодуле __main__ .
Обратите внимание, что выводится также и адрес в памяти компьютера, где
хранится ваш объект. На вашем компьютере адрес будет другим, так как
Pythonхранитобъектытам,гдеимеетсясвободноеместо.
14.3
Методы объектов
Итак, мы выяснили что классы/объекты могут иметь методы, представляющие собой
функции,заисключениемдополнительнойпеременной self.Атеперьдавайтерассмот-
римпример(сохранитекак method.py ).
class Person :
def sayHi (self ):
print ('Привет! Как дела? ')
p=Person()
p.sayHi()
# Этот короткий пример можно также записать как Person().sayHi()
Вывод:
$ python3 method.py
Привет! Как дела?
Как это работает:
Здесь мы видим selfв действии. Обратите внимание, что метод sayHiне
принимаетпараметров,нотемнеменее,имеет selfвопределениифункции.
14.3. Методы объектов 110A Byte of Python (Russian), Версия 2.02
14.4
Метод __init__
Существует много методов, играющих специальную роль в классах Python. Сейчас мы
увидимзначительностьметода __init__ .
Метод __init__ запускается, как только объект класса реализуется. Этот метод полезен
дляосуществленияразногорода инициализации ,необходимойдляданногообъекта.Об-
ратитевниманиенадвойныеподчёркиваниявначалеивконцеимени.
Пример: (сохранитекак oop_init.py )
class Person :
def __init__ (self , name):
self .name =name
def say_hi (self ):
print ('Привет! Меня зовут ',self .name)
p=Person( 'Swaroop ')
p.say_hi()
# Предыдущие 2 строки можно
# Person('Swaroop').say_hi()
Вывод:
$ python oop_init.py
Привет! Меня зовут Swaroop
Как это работает:
Здесьмыопределяемметод __init__ так,чтобыонпринималпараметр name
(наряду с обычным self). Далее мы создаём новое поле с именем name. Об-
ратите внимание, что это две разные переменные, даже несмотря на то, что
они обе названы name. Это не проблема, так как точка в выражении self.
nameобозначает,чтосуществуетнечтосименем«name»,являющеесячастью
объекта«self»,идругое name–локальнаяпеременная.Посколькумывявном
видеуказываем,ккоторомуименимыобращаемся,путаницыневозникнет.
Для создания нового экземпляра pкласса Personмы указываем имя класса,
послекоторого–аргументывскобках: p = Person('Swaroop') .
Метод __init__ мы при этом не вызываем явным образом. В этом и заклю-
чаетсяспециальнаярольданногометода.
Послеэтогомыполучаемвозможностьиспользоватьполе self.name внаших
методах,чтоипродемонстрировановметоде say_hi.
14.4. Метод __init__ 111A Byte of Python (Russian), Версия 2.02
14.5
Переменные класса и объекта
Функциональную часть классов и объектов (т.е. методы) мы обсудили, теперь давайте
ознакомимся с частью данных. Данные, т.е. поля, являются не чем иным, как обычны-
мипеременными, заключёнными впространствах имён классовиобъектов.Этоознача-
ет,чтоихименадействительнытольковконтекстеэтихклассовилиобъектов.Отсюдаи
название« пространство имён ».
Существует два типа полей: переменные класса и переменные объекта, которые разли-
чаются в зависимости от того, принадлежит ли переменная классу или объекту соответ-
ственно.
Переменные класса разделяемы–доступкниммогутполучатьвсеэкземплярыэтогоклас-
са. Переменная класса существует только одна, поэтому когда любой из объектов изме-
няетпеременнуюкласса,этоизменениеотразитсяивовсехостальныхэкземплярахтого
жекласса.
Переменные объекта принадлежаткаждомуотдельномуэкземплярукласса.Вэтомслучае
укаждогообъектаестьсвоясобственнаякопияполя,т.е.неразделяемаяиникоимобразом
не связанная с другими такими же полями в других экземплярах. Это легко понять на
примере(сохранитекак objvar.py ):
class Robot :
'''Представляет робота с именем.'''
# Переменная класса, содержащая количество роботов
population =0
def __init__ (self , name):
'''Инициализация данных.'''
self .name =name
print ('(Инициализация {0})'.format( self .name))
# При создании этой личности, робот добавляется
# к переменной 'population'
Robot .population +=1
def __del__ (self ):
'''Я умираю.'''
print ('{0} уничтожается! '.format( self .name))
Robot .population -=1
ifRobot .population ==0:
print ('{0} был последним. '.format( self .name))
else :
print ('Осталось {0:d} работающих роботов. '.format( \
(продолжениенаследующейстранице)
14.5. Переменные класса и объекта 112A Byte of Python (Russian), Версия 2.02
(продолжениеспредыдущейстраницы)
Robot .population))
def sayHi (self ):
'''Приветствие робота.
Да, они это могут.'''
print ('Приветствую! Мои хозяева называют меня {0}.'.format( self .name))
def howMany ():
'''Выводит численность роботов.'''
print ('У нас {0:d} роботов. '.format(Robot .population))
howMany =staticmethod (howMany)
droid1 =Robot( 'R2-D2 ')
droid1 .sayHi()
Robot .howMany()
droid2 =Robot( 'C-3PO ')
droid2 .sayHi()
Robot .howMany()
print ("\nЗдесь роботы могут проделать какую-то работу. \n")
print ("Роботы закончили свою работу. Давайте уничтожим их. ")
del droid1
del droid2
Robot .howMany()
Вывод:
$ python3 objvar.py
(Инициализация R2-D2)
Приветствую! Мои хозяева называют меня R2-D2.
У нас 1 роботов.
(Инициализация C-3PO)
Приветствую! Мои хозяева называют меня C-3PO.
У нас 2 роботов.
Здесь роботы могут проделать какую-то работу.
Роботы закончили свою работу. Давайте уничтожим их.
R2-D2 уничтожается!
Осталось 1 работающих роботов.
(продолжениенаследующейстранице)
14.5. Переменные класса и объекта 113A Byte of Python (Russian), Версия 2.02
(продолжениеспредыдущейстраницы)
C-3PO уничтожается!
C-3PO был последним.
У нас 0 роботов.
Как это работает:
Этодлинныйпример,ноонпомогаетпродемонстрироватьприродуперемен-
ныхклассаиобъекта.Здесь population принадлежитклассу Robot,ипоэто-
му является переменной класса. Переменная nameпринадлежит объекту (ей
присваиваетсязначениеприпомощи self),ипоэтомуявляетсяпеременной
объекта.
Такимобразом,мыобращаемсякпеременнойкласса population какRobot.
population , а не self.population . К переменной же объекта nameво всех
методахэтогообъектамыобращаемсяприпомощиобозначения self.name .
Помнитеобэтойпростойразницемеждупеременнымиклассаиобъекта.Так-
жеимейтеввиду,чтопеременнаяобъектастемжеименем,чтоипеременная
класса,сделаетнедоступной(«спрячет»)переменнуюкласса!
Метод howManyпринадлежит классу, а не объекту. Это означает, что мы мо-
жем определить его как classmethod илиstaticmethod , в зависимости от
того, нужно ли нам знать, в каком классе мы находимся. Поскольку нам не
нужнатакаяинформация,мывоспользуемся staticmethod .
Мымоглидостичьтогожесамого,используя декораторы :
@staticmethod
def howMany ():
'''Выводит численность роботов.'''
print ('У нас {0:d} роботов. '.format(Robot .population))
Декораторыможносчитатьнекимупрощённымспособомвызоваявногооператора,как
мывиделивэтомпримере.
Пронаблюдайте, как метод __init__ используется для инициализации экземпляра
Robotсименем.Вэтомметодемыувеличиваемсчётчик population на1,таккакдобав-
ляем ещё одного робота. Также заметьте, что значения self.name для каждого объекта
свои,чтоуказываетнаприродупеременныхобъекта.
Помните, что к переменным и методам самого объекта нужно обращаться, пользуясь
только self.Этоназывается доступом к атрибутам .
Вэтомпримеремытакженаблюдалиприменение строк документации дляклассов,рав-
нокакидляметодов.Вовремявыполнениямыможемобращатьсякстрокедокументации
класса при помощи « Robot.__doc__ », а к строке документации метода – при помощи
«Robot.sayHi.__doc__ ».
Нарядусметодом __init__ ,существуетидругойспециальныйметод __del__,который
14.5. Переменные класса и объекта 114A Byte of Python (Russian), Версия 2.02
вызываетсятогда,когдаобъектсобираетсяумереть,т.е.когдаонбольшенеиспользуется,
и занимаемая им память возвращается операционной системе для другого использова-
ния.Вэтомметодемыпростоуменьшаемсчётчик Robot.population на1.
Метод __del__запускаетсялишьтогда,когдаобъектперестаётиспользоваться,апоэто-
музаранеенеизвестно, когдаименноэтотмоментнаступит.Чтобыувидетьеговдействии
явно,придётсявоспользоватьсяоператором del,чтомыисделаливыше.
Примечание для программистов на C++/Java/C#
ВPythonвсечленыкласса(включаяданные)являются публичными (public),авсеметоды
–виртуальными (virtual).
Исключение:Еслиимяпеременнойначинаетсяс двойного подчёркивания ,как,например,
__privatevar ,Pythonделаетэтупеременнуюприватной(private).Поэтомупринятоимя
любой переменной, которая должна использоваться только внутри класса или объекта,
начинать с подчёркивания; все же остальные имена являются публичными, и могут ис-
пользоватьсявдругихклассах/объектах.Помните,чтоэтолишьтрадиция,иPythonвовсе
необязываетделатьименнотак(кромедвойногоподчёркивания).
14.6
Наследование
Одно из главных достоинств объектно-ориентированного программирования заключа-
ется в многократном использовании одного и того же кода, и один из способов этого
достичь–припомощимеханизма наследования .Легчевсегопредставитьсебенаследова-
ниеввидеотношениямеждуклассамикак тип и подтип .
Представим, что нам нужно написать программу, которая отслеживает информацию о
преподавателях и студентах в колледже. У них есть некоторые общие характеристики:
имя, возраст и адрес. Есть также и специфические характеристики, такие как зарплата,
курсыиотпускдляпреподавателей,атакжеоценкииоплатазаобучениедлястудентов.
Можно создать для них независимые классы и работать с ними, но тогда добавление
какой-либо новой общей характеристики потребует добавления её к каждому из этих
независимыхклассоввотдельности,чтоделаетпрограммунеповоротливой.
Лучше создать общий класс с именем SchoolMember , а затем сделать так, чтобы классы
преподавателя и студента наследовали этот класс, т.е. чтобы они стали подтипами этого
типа(класса),после чегодобавить любыеспецифические характеристикик этимподти-
пам.
У такого подхода есть множество достоинств. Если мы добавим/изменим какую-либо
функциональностьв SchoolMember ,этоавтоматическиотобразитсяивовсехподтипах.
Например,мыможемдобавитьновоеполеудостоверениядляпреподавателейистуден-
тов,простодобавивегокклассу SchoolMember .Сдругойстороны,изменениявподтипах
14.6. Наследование 115A Byte of Python (Russian), Версия 2.02
никакневлияютнадругиеподтипы.Ещёоднодостоинствосостоитвтом,чтообращать-
сякобъектупреподавателяилистудентаможнокаккобъекту SchoolMember ,чтоможет
быть полезно в ряде случаев, например, для подсчёта количества человек в школе. Ко-
гдаподтипможетбытьподставленвлюбомместе,гдеожидаетсяродительскийтип,т.е.
объектсчитаетсяэкземпляромродительскогокласса,этоназывается полиморфизмом .
Заметьтетакже,чтокодродительскогокласса используется многократно ,инетнеобходи-
мостикопироватьегововсеклассы,какпришлосьбывслучаеиспользованиянезависи-
мыхклассов.
Класс SchoolMember вэтойситуацииназывают базовым классом или надклассом3.Классы
TeacherиStudentназывают производными классами или подклассами4.
Рассмотримтеперьэтотпримерввидепрограммы(сохранитекак inherit.py ).
class SchoolMember :
'''Представляет любого человека в школе.'''
def __init__ (self , name, age):
self .name =name
self .age =age
print ('(Создан SchoolMember: {0})'.format( self .name))
def tell (self ):
'''Вывести информацию.'''
print ('Имя: "{0}"Возраст: "{1}"'.format( self .name, self .age), end ="")
class Teacher (SchoolMember):
'''Представляет преподавателя.'''
def __init__ (self , name, age, salary):
SchoolMember .__init__ (self , name, age)
self .salary =salary
print ('(Создан Teacher: {0})'.format( self .name))
def tell (self ):
SchoolMember .tell( self )
print ('Зарплата: "{0:d} "'.format( self .salary))
class Student (SchoolMember):
'''Представляет студента.'''
def __init__ (self , name, age, marks):
SchoolMember .__init__ (self , name, age)
self .marks =marks
print ('(Создан Student: {0})'.format( self .name))
def tell (self ):
SchoolMember .tell( self )
(продолжениенаследующейстранице)
3также«суперкласс»,«родительскийкласс»( прим.перев. )
4также«субкласс»,«класс-наследник»( прим.перев. )
14.6. Наследование 116A Byte of Python (Russian), Версия 2.02
(продолжениеспредыдущейстраницы)
print ('Оценки: "{0:d} "'.format( self .marks))
t=Teacher( 'Mrs. Shrividya ',40,30000 )
s=Student( 'Swaroop ',25,75)
print ()# печатает пустую строку
members =[t, s]
for member inmembers:
member .tell() # работает как для преподавателя, так и для студента
Вывод:
$ python3 inherit.py
(Создан SchoolMember: Mrs. Shrividya)
(Создан Teacher: Mrs. Shrividya)
(Создан SchoolMember: Swaroop)
(Создан Student: Swaroop)
Имя:"Mrs. Shrividya" Возраст:"40" Зарплата: "30000"
Имя:"Swaroop" Возраст:"25" Оценки: "75"
Как это работает:
Чтобывоспользоватьсянаследованием,приопределенииклассамыуказыва-
ем имена его базовых классов в виде кортежа, следующего сразу за его име-
нем. Далее мы видим, что метод __init__ базового класса вызывается явно
припомощипеременной self,чтобыинициализироватьчастьобъекта,отно-
сящуюсякбазовомуклассу.Этооченьважнозапомнить:посколькумыопре-
деляемметод __init__ вподклассах TeacherиStudent,Pythonневызывает
конструкторбазовогокласса SchoolMember автоматически–егонеобходимо
вызыватьсамостоятельновявномвиде.
Напротив,еслимы неопределимметод __init__ вподклассе,Pythonвызовет
конструкторбазовогоклассаавтоматически.
Здесь же мы видим, как можно вызывать методы базового класса, предваряя
записьимениметодаименемкласса,азатемпередаваяпеременную selfвме-
стесдругимиаргументами.
Обратите внимание, что при вызове метода tellиз класса SchoolMember
экземпляры Teacher или Student можно использовать как экземпляры
SchoolMember .
Заметьтетакже,чтовызываетсяметод tellизподкласса,анеметод tellиз
класса SchoolMember . Это можно понять следующим образом: Python всегда
начинаетпоискметодоввсамомклассе,чтоониделаетвданномслучае.Если
14.6. Наследование 117A Byte of Python (Russian), Версия 2.02
же он не находит метода, он начинает искать методы, принадлежащие базо-
вымклассампоочереди,впорядке,вкоторомониперечисленывкортежепри
определениикласса.
Замечание по терминологии: если при наследовании перечислено более од-
ногокласса,этоназывается множественным наследованием .
Параметр endиспользуетсявметоде tell()длятого,чтобыноваястрокана-
чиналасьчерезпробелпослевызова print().
14.7
Метаклассы5
Вобширнойтемеобъектно-ориентированногопрограммированиясуществуетещёмного
всего,номылишьслегкакоснёмсянекоторыхконцепций,чтобывыпростозналиобих
существовании.
Точнотакже,какклассыиспользуютсядлясозданияобъектов,можноиспользоватьме-
таклассыдлясозданияклассов.Метаклассысуществуютдляизмененияилидобавления
новогоповедениявклассы.
Давайтерассмотримпример.Допустим,мыхотимбытьуверены,чтомывсегдасоздаём
исключительноэкземплярыподклассовкласса SchoolMember ,инесоздаёмэкземпляры
самогокласса SchoolMember .
Длядостиженияэтойцелимыможемиспользоватьконцепциюподназванием«абстракт-
ныебазовыеклассы».Этоозначает,чтотакойкласс абстрактен ,т.е.являетсялишьнекой
концепцией,непредназначеннойдляиспользованиявкачествереальногокласса.
Мыможемобъявитьнашкласскакабстрактныйбазовыйклассприпомощивстроенного
метаклассапоимени ABCMeta.
#!/usr/bin/env python
# Filename: inherit_abc.py
from abc import *
class SchoolMember (metaclass =ABCMeta):
'''Представляет любого человека в школе.'''
def __init__ (self , name, age):
self .name =name
self .age =age
print ('(Создан SchoolMember: {0})'.format( self .name))
(продолжениенаследующейстранице)
5воригинальнойверсиикнигиэтотпараграфневидимдлячитателей,таккакнаходитсявкомментарии
с пометкой автора «It is too sudden to introduce this concept here.», что означает «Слишком неожиданно
представлениеэтойконцепцииздесь.»( прим.перев. )
14.7. Метаклассы5118A Byte of Python (Russian), Версия 2.02
(продолжениеспредыдущейстраницы)
@abstractmethod
def tell (self ):
'''Вывести информацию.'''
print ('Имя: "{0}"Возраст: "{1}"'.format( self .name, self .age), end ="")
class Teacher (SchoolMember):
'''Представляет преподавателя.'''
def __init__ (self , name, age, salary):
SchoolMember .__init__ (self , name, age)
self .salary =salary
print ('(Создан Teacher: {0})'.format( self .name))
def tell (self ):
SchoolMember .tell( self )
print ('Зарплата: "{0:d} "'.format( self .salary))
class Student (SchoolMember):
'''Представляет студента.'''
def __init__ (self , name, age, marks):
SchoolMember .__init__ (self , name, age)
self .marks =marks
print ('(Создан Student: {0})'.format( self .name))
def tell (self ):
SchoolMember .tell( self )
print ('Оценки: "{0:d} "'.format( self .marks))
t=Teacher( 'Mrs. Shrividya ',40,30000 )
s=Student( 'Swaroop ',25,75)
#m = SchoolMember('abc', 10)
# Это приведёт к ошибке: "TypeError: Can't instantiate abstract class
# SchoolMember with abstract methods tell"
print ()# печатает пустую строку
members =[t, s]
for member inmembers:
member .tell() # работает как для преподавателя, так и для студента
Вывод:
$ python3 inherit.py
(Создан SchoolMember: Mrs. Shrividya)
(Создан Teacher: Mrs. Shrividya)
(продолжениенаследующейстранице)
14.7. Метаклассы5119A Byte of Python (Russian), Версия 2.02
(продолжениеспредыдущейстраницы)
(Создан SchoolMember: Swaroop)
(Создан Student: Swaroop)
Имя:"Mrs. Shrividya" Возраст:"40" Зарплата: "30000"
Имя:"Swaroop" Возраст:"25" Оценки: "75"
Как это работает:
Мы можем объявить метод tellкласса SchoolMember абстрактным, и таким образом
автоматическизапретимсоздаватьэкземплярыкласса SchoolMember .
Темнеменее,мыможемработатьсэкземплярами TeacherиStudentтак,какбудтоони
экземпляры SchoolMember ,посколькуониявляютсяподклассами.
14.8
Резюме
Мы изучили различные аспекты классов и объектов, равно как и терминологию,
связанную с ними. Мы также увидели ряд достоинств и «подводных камней»
объектно-ориентированного программирования. Python – в высокой степени объектно-
ориентирован,поэтомупониманиеэтихпринциповоченьпоможетвамвдальнейшем.
Далеемыузнаем,какработатьсвводом/выводомиполучатьдоступкфайламвPython.
14.8. Резюме 120Ввод-вывод
Рано или поздно возникают ситуации, когда программа должна взаимодействовать с
пользователем. Например, принять какие-нибудь данные от пользователя, а затем вы-
вестирезультаты.Дляэтогоприменяютсяфункции input()иprint()соответственно.
Длявыводаможнотакжеиспользоватьразличныеметодыкласса str(строка).Кпримеру,
при помощи метода rjustможно получить строку, выравненную по правому краю к
указаннойширине.См. help(str) дляболееподробногоописания.
Ещёоднимраспространённымтипомввода/выводаявляетсяработасфайлами.Возмож-
ностьсоздавать,читатьизаписыватьвфайлыявляетсяключевойдлямногихпрограмм,
поэтомувнастоящейглавеимырассмотримэтотаспект.
15.1
Ввод от пользователя
Сохранитеэтупрограммукак user_input.py :
def reverse (text):
return text[:: -1]
def is_palindrome (text):
return text ==reverse(text)
something =input ('Введите текст: ')
if(is_palindrome(something)):
print ("Да, это палиндром ")
else :
print ("Нет, это не палиндром ")
Вывод:
$ python3 user_input.py
Введите текст: сэр
Нет, это не палиндром
(продолжениенаследующейстранице)
121A Byte of Python (Russian), Версия 2.02
(продолжениеспредыдущейстраницы)
$ python3 user_input.py
Введите текст: мадам
Да, это палиндром
$ python3 user_input.py
Введите текст: топот
Да, это палиндром
Как это работает:
Мы применяем операцию вырезки для переворачивания текста. Мы уже
видели, как создаются вырезки из последовательностей при помощи кода
«seq[a:b] »,начинаяспозиции aдопозиции b.Новедьмытакжеможемука-
затьитретийаргумент,определяющий шаг,скоторымпроизводитсявырезка.
Поумолчаниюшагравен 1,поэтомуивозвращаетсянепрерывныйфрагмент
текста. Указание отрицательного шага, т.е. -1приведёт к выводу текста в об-
ратномпорядке.
Функция input() принимает строку в качестве аргумента и показывает её
пользователю. Затем она ждёт, чтобы пользователь набрал что-нибудь и на-
жал клавишу ввода. Как только пользователь это сделал, функция input()
возвращаетвведённыйпользователемтекст.
Мы считываем этот текст и выстраиваем его в обратном порядке. Если пе-
ревёрнутый и исходный текст одинаковы, значит введённый текст является
палиндромом .
Домашнее задание
Проверка, является ли текст палиндромом должна также игнорировать знаки пунктуа-
ции, пробелы и регистр букв. Например, «А роза упала на лапу Азора» также является
палиндромом,нонашатекущаяпрограмматакнесчитает.Попробуйтеулучшитьеётак,
чтобыонараспозналаэтотпалиндром.
Подсказка: (не читайте)
Воспользуйтеськортежем(список всехзнаковпунктуацииможнонайти здесь),содержа-
щим все запрещённые символы, и примените тест на принадлежность, чтобы обнару-
житьсимволы,подлежащиеудалению,т.е.forbidden=(„!“,„?“,„.“,…).
15.1. Ввод от пользователя 122A Byte of Python (Russian), Версия 2.02
15.2
Файлы
Открыватьииспользоватьфайлыдлячтенияилизаписиможнопутёмсозданияобъекта
класса file,ачитать/записыватьвфайл–припомощиегометодов read,readline или
writeсоответственно. Возможность читать или записывать в файл зависит от режима,
указанного при открытии файла. По окончании работы с файлом, нужно вызвать метод
close1,чтобыуказатьPython,чтофайлбольшенеиспользуется.
Пример: (сохранитекак using_file.py )
poem ='''\
Программировать весело.
Если работа скучна,
Чтобы придать ей весёлый тон -
используй Python!
'''
f=open ('poem.txt ','w')# открываем для записи (writing)
f.write(poem) # записываем текст в файл
f.close() # закрываем файл
f=open ('poem.txt ')# если не указан режим, по умолчанию подразумевается
# режим чтения ('r'eading)
while True :
line =f.readline()
iflen(line) ==0:# Нулевая длина обозначает конец файла (EOF)
break
print (line, end ='')
f.close() # закрываем файл
Вывод:
$ python3 using_file.py
Программировать весело.
Если работа скучна,
Чтобы придать ей весёлый тон -
используй Python!
Как это работает:
Сперва мы открываем файл при помощи встроенной функции openс указа-
ниемименифайлаирежима,вкотороммыхотимегооткрыть.Режимможет
бытьдлячтения( 'r'),записи( 'w')илидобавления( 'a')2.Можнотакжеука-
зать, в каком виде мы будем считывать, записывать или добавлять данные:
1close– англ.«закрывать»( прим.перев )
2read, writeи appendсоответственно( прим.перев. )
15.2. Файлы 123A Byte of Python (Russian), Версия 2.02
втекстовом( 't')илибинарном( 'b').Насамомделесуществуетмногодру-
гих режимов, и help(open) даст вам их детальное описание. По умолчанию
open()открываетфайлкактекстврежимедлячтения.
В нашем примере мы сначала открываем файл в режиме записи текста и ис-
пользуем метод writeфайлового объекта для записи в файл, после чего за-
крываемфайлприпомощи close.
Далеемыоткрываемтотжесамыйфайлдлячтения.Вэтомслучаенетнужды
указыватьрежим,таккакрежим«чтениятекстовогофайла»применяетсяпо
умолчанию.Мысчитываемфайлпострочнометодом readline вцикле.Этот
метод возвращает полную строку, включая символ перевода строки в конце.
Когдажеонвозвращаетпустуюстроку,этоозначает,чтомыдостигликонца
файла,имыпрерываемциклприпомощи break.
Поумолчаниюфункция print()выводиттекст,автоматическидобавляясим-
вол перевода строки в конце. Мы подавляем этот символ, указывая end='',
поскольку строки, считанные из файла, и без того оканчиваются символом
переводастроки.И,наконец,мызакрываемфайлспомощью close.
Теперь проверяем содержимое файла poem.txt , чтобы убедиться, что про-
граммадействительнозаписалатекствнегоисчиталаизнего.
15.3
Pickle
Pythonпредоставляетстандартныймодульсименем pickle3,припомощикоторогомож-
носохранять любойобъектPythonвфайле,азатемизвлекатьегообратно.Этоназывается
длительным хранениемобъекта.
Пример: (сохранитекак pickling.py ):
import pickle
# имя файла, в котором мы сохраним объект
shoplistfile ='shoplist.data '
# список покупок
shoplist =['яблоки ','манго ','морковь ']
# Запись в файл
f=open (shoplistfile, 'wb')
pickle .dump(shoplist, f) # помещаем объект в файл
f.close()
del shoplist # уничтожаем переменную shoplist
(продолжениенаследующейстранице)
3pickle– англ.«мариновать»,«солить»( прим.перев. )
15.3. Pickle 124A Byte of Python (Russian), Версия 2.02
(продолжениеспредыдущейстраницы)
# Считываем из хранилища
f=open (shoplistfile, 'rb')
storedlist =pickle .load(f) # загружаем объект из файла
print (storedlist)
Вывод:
$ python3 pickling.py
['яблоки', 'манго', 'морковь']
Как это работает:
Чтобысохранитьобъектвфайле,намнужносперваоткрытьфайлспомощью
openврежимебинарнойзаписи( 'wb'),послечеговызватьфункцию dumpиз
модуля pickle.Этотпроцессназывается«консервацией»(«pickling»).
После этого мы извлекаем объект при помощи функции loadиз модуля
pickle, которая возвращает объект. Этот процесс называется «расконсерва-
цией»(«unpickling»).
15.4
Резюме
Мыобсудилиразныетипыввода/вывода,атакжеработусфайламиииспользованиемо-
дуля pickle.
Далеемыпознакомимсясконцепциейисключений.
15.4. Резюме 125Исключения
Исключения возникают тогда, когда в программе возникает некоторая исключительная
ситуация.Например,кчемуприведётпопыткачтениянесуществующегофайла?Илиес-
лифайлбылслучайноудалён,покапрограммаработала?Такиеситуацииобрабатывают-
сяприпомощи исключений .
Этокасаетсяипрограмм,содержащихнедействительныекоманды.ВэтомслучаеPython
поднимает рукиисообщает,чтообнаружил ошибку.
16.1
Ошибки
Рассмотримпростойвызовфункции print.Что,еслимыошибочнонапишем printкак
Print?Обратитевниманиеназаглавнуюбукву.ВэтомслучаеPython поднимает синтак-
сическуюошибку.
>>> Print( 'Привет, Мир! ')
Traceback (most recent call last):
File "<pyshell#0>" , line 1, in <module>
Print( 'Привет, Мир! ')
NameError : name 'Print' is not defined
>>> print ('Привет, Мир! ')
Привет, Мир!
Обратите внимание, что была поднята ошибка NameError , а также указано место, где
былаобнаруженаошибка.Таквданномслучаедействует обработчик ошибок .
16.2
Исключения
Попытаемся считатьчто-либоотпользователя.Нажмите Сtrl-D(или Ctrl+ZвWindows)
ипосмотрите,чтопроизойдёт.
>>> s=input ('Введите что-нибудь --> ')
Введите что-нибудь -->
(продолжениенаследующейстранице)
126A Byte of Python (Russian), Версия 2.02
(продолжениеспредыдущейстраницы)
Traceback (most recent call last):
File "<pyshell#2>" , line 1, in <module>
s=input ('Введите что-нибудь --> ')
EOFError : EOF when reading a line
Python поднимает ошибку с именем EOFError , что означает, что он обнаружил символ
конца файла (которыйвводитсяприпомощи Ctrl-D)там,гденеожидал.
16.3
Обработка исключений
Обрабатывать исключения можно при помощи оператора try..except1. При этом все
обычные команды помещаются внутрь try-блока, а все обработчики исключений – в
except-блок.
Пример: (сохранитекак try_except.py )
try:
text =input ('Введите что-нибудь --> ')
except EOFError :
print ('Ну зачем вы сделали мне EOF? ')
except KeyboardInterrupt :
print ('Вы отменили операцию. ')
else :
print ('Вы ввели {0}'.format(text))
Вывод:
$ python3 try_except.py
Введите что-нибудь --> # Нажмите ctrl-d
Ну зачем вы сделали мне EOF?
$ python3 try_except.py
Введите что-нибудь --> # Нажмите ctrl-c
Вы отменили операцию.
$ python3 try_except.py
Введите что-нибудь --> без ошибок
Вы ввели без ошибок
Как это работает:
Здесь мы поместили все команды, которые могут вызвать исключе-
ния/ошибки, внутрь блока try, а затем поместили обработчики соответству-
1try– англ.«пытаться»( прим.перев. )
16.3. Обработка исключений 127A Byte of Python (Russian), Версия 2.02
ющих ошибок/исключений в блок except. Выражение exceptможет об-
рабатывать как одиночную ошибку или исключение, так и список оши-
бок/исключенийвскобках.Еслинеуказаноимяошибкиилиисключения,об-
рабатыватьсябудут всеошибкииисключения.
Помните, что для каждого выражения tryдолжно быть хотя бы одно соответствующее
выражение except.Иначекакойсмыслбылбывблоке try?
Если ошибка или исключение не обработано, будет вызван обработчик Python по умол-
чанию, который останавливает выполнение программы и выводит на экран сообщение
обошибке.Вышемыужевиделиэтовдействии.
Можнотакжедобавитьпункт elseксоответствующемублоку try..except .Этотпункт
будетвыполнентогда,когдаисключенийневозникает.
Вследующемпримеремыувидим,какможнополучитьобъектисключениядлядальней-
шейработысним.
16.4
Вызов исключения
Исключение можно поднятьпри помощи оператора raise2, передав ему имя ошиб-
ки/исключения,атакжеобъектисключения,которыйнужно выбросить .
Вызываемаяошибкаилиисключениедолжнабытьклассом,которыйпрямоилинепрямо
являетсяпроизводнымоткласса Exception .
Пример: (сохранитекак raising.py )
class ShortInputException (Exception ):
'''Пользовательский класс исключения.'''
def __init__ (self , length, atleast):
Exception .__init__ (self )
self .length =length
self .atleast =atleast
try:
text =input ('Введите что-нибудь --> ')
iflen(text) <3:
raise ShortInputException( len(text), 3)
# Здесь может происходить обычная работа
except EOFError :
print ('Ну зачем вы сделали мне EOF? ')
except ShortInputException asex:
print ('ShortInputException: Длина введённой строки -- {0};\
ожидалось, как минимум, {1}'.format(ex .length, ex .atleast))
(продолжениенаследующейстранице)
2raise– англ.«поднимать»( прим.перев. )
16.4. Вызов исключения 128A Byte of Python (Russian), Версия 2.02
(продолжениеспредыдущейстраницы)
else :
print ('Не было исключений. ')
Вывод:
$ python3 raising.py
Введите что-нибудь --> а
ShortInputException: Длина введённой строки -- 1; ожидалось, как минимум, 3
$ python3 raising.py
Введите что-нибудь --> абв
Не было исключений.
Как это работает:
Здесьмысоздаёмнашсобственныйтиписключения.Этотновыйтиписклю-
ченияназывается ShortInputException .Онсодержитдваполя: length,хра-
нящеедлинувведённоготекста,и atleast,указывающее,какуюминималь-
нуюдлинутекстаожидалапрограмма.
В пункте exceptмы указываем класс ошибки ShortInputException , кото-
рый будет сохранён как3переменная ex, содержащая соответствующий объ-
ект ошибки/исключения. Это аналогично параметрам и аргументам при вы-
зове функции. Внутри этого пункта exceptмы используем поля lengthи
atleastобъектаисключениядлявыводанеобходимыхсообщенийпользова-
телю.
16.5
Try .. Finally
Представим,чтовпрограммепроисходитчтениефайлаинеобходимоубедиться,чтообъ-
ект файла был корректно закрыт и что не возникло никакого исключения. Этого можно
достичьсприменениемблока finally.
Сохранитекак finally.py :
import time
try:
f=open ('poem.txt ')
while True :# наш обычный способ читать файлы
line =f.readline()
iflen(line) ==0:
(продолжениенаследующейстранице)
3as– англ.«как»( прим.перев. )
16.5. Try .. Finally 129A Byte of Python (Russian), Версия 2.02
(продолжениеспредыдущейстраницы)
break
print (line, end ='')
time .sleep( 2)# Пусть подождёт некоторое время
except KeyboardInterrupt :
print ('!! Вы отменили чтение файла. ')
finally :
f.close()
print ('(Очистка: Закрытие файла) ')
Вывод:
$ python3 finally.py
Программировать весело
Если работа скучна,
Чтобы придать ей весёлый тон -
!! Вы отменили чтение файла.
(Очистка: Закрытие файла)
Как это работает:
Здесьмыпроизводимобычныеоперациичтенияизфайла,новданномслу-
чаедобавляемдвухсекундныйсонпослевыводакаждойстрокиприпомощи
функции time.sleep ,чтобыпрограммавыполняласьмедленно(ведьPython
оченьбыстротприроды).Вовремявыполненияпрограммынажмите ctrl-c,
чтобыпрервать/отменитьвыполнениепрограммы.
Пронаблюдайте, как при этом выдаётся исключение KeyboardInterrupt , и
программа выходит. Однако, прежде чем программа выйдет, выполняется
пункт finally,ифайловыйобъектбудетвсегдазакрыт.
16.6
Оператор with
Типичнойсхемойявляетсязапроснекоторогоресурсавблоке tryспоследующимосво-
бождением этого ресурса в блоке finally. Для того, чтобы сделать это более «чисто»,
существуетоператор with4:
Сохранитекак using_with.py :
with open ("poem.txt ")asf:
for line inf:
print (line, end ='')
4with– англ.«с»( прим.перев. )
16.6. Оператор with 130A Byte of Python (Russian), Версия 2.02
Как это работает:
Выводдолженбытьтакимже,какивпредыдущемпримере.Разницалишьв
том, что здесь мы используем функцию openс оператором with– этим мы
оставляемавтоматическоезакрытиефайлаподответственность with open .
Закулисамипроисходитследующее.Существуетнекийпротокол,используе-
мыйоператором with.Онсчитываетобъект,возвращаемыйоператором open.
Назовёмеговданномслучае«thefile».
Перед запуском блока кода, содержащегося в нём, оператор with всегдавы-
зывает функцию thefile.__enter__ , а также всегдавызывает thefile.
__exit__ послезавершениявыполненияэтогоблокакода.
Такчтокод,которыймыбынаписаливблоке finally,будетавтоматически
обработанметодом __exit__ .Этоизбавляетнасотнеобходимостиповторно
вявномвидеуказыватьоператоры try..finally .
Болееобширноерассмотрениеэтойтемывыходитзарамкинастоящейкниги,
поэтомудляболееисчерпывающегообъяснениясм. PEP 343.
16.7
Резюме
Мыобсудилииспользованиеоператоров try..except иtry..finally .Мытакжеуви-
дели,каксоздаватьнашисобственныетипыисключенийикакихвызывать.
ДалеемыознакомимсясостандартнойбиблиотекойPython.
16.7. Резюме 131Стандартная библиотека
СтандартнаябиблиотекаPythonсодержитогромноеколичествополезныхмодулейияв-
ляется частью стандартного комплекта поставки Python. Ознакомиться со стандартной
библиотекойPythonоченьважно,таккакмножествозадачможнорешитьоченьбыстро,
есливызнакомысвозможностямиэтихбиблиотек.
Рассмотрим некоторые наиболее часто используемые модули этой библиотеки. Деталь-
ное описание всех модулей стандартной библиотеки Python можно найти в разделе
«LibraryReference» документации,входящейвкомплектпоставкиPython.
Давайтеизучимнесколькополезныхмодулей.
Примечание
Если темы в настоящей главе покажутся вам слишком сложными, вы можете её пропу-
стить. Однако я настоятельно рекомендую вернуться к этой главе, когда вы будете чув-
ствоватьсебяболееуверенносPython.
17.1
Модуль sys
Модуль sysсодержитфункциональность,характернуюдлясистемы.Такмывидели,что
список sys.argv содержитаргументыкоманднойстроки.
Предположим, нам нужно узнать версию используемой команды Python с тем, чтобы, к
примеру,убедитьсявтом,чтомыиспользуемкакминимумверсию3.Модуль sysпредо-
ставляеттакуювозможность.
>>> import sys
>>> sys.version_info
(3, 0, 0, 'beta', 2)
>>> sys.version_info[ 0]>=3
True
132A Byte of Python (Russian), Версия 2.02
Как это работает:
Модуль sysсодержиткортеж version_info ,которыйхранитинформациюо
версии. Первый элемент этого кортежа обозначает старшую версию. Мы мо-
жем использовать его, например, для того, чтобы убедиться, что программа
будетвыполнятьсятольковPython3.0:
Сохранитекак versioncheck.py :
import sys,warnings
ifsys.version_info[ 0]<3:
warnings .warn( "Для выполнения этой программы необходима как минимум \
версия Python 3.0 ",
RuntimeWarning )
else :
print ('Нормальное продолжение ')
Вывод:
$ python2.7 versioncheck.py
versioncheck.py:6: Для выполнения этой программы необходима как минимум ￿
,→версия Python 3.0
RuntimeWarning)
$ python3 versioncheck.py
Нормальное продолжение
Как это работает:
Мыиспользуем одиниз модулейстандартной библиотеки,который называ-
етсяwarnings ислужитдляотображенияпредупрежденийпользователю.Ес-
ливерсияPythonменее3,мыпоказываемсоответствующеепредупреждение.
17.2
Модуль logging
Представьте ситуацию, когда необходимо сохранить некоторые отладочные или другие
важные сообщения где-нибудь, чтобы иметь возможность позже проверить, отработала
ли программа, как ожидалось. Как мы «сохраним где-нибудь» эти сообщения? Сделать
этоможноприпомощимодуля logging.
Сохранитекак use_logging.py :
import os,platform ,logging
ifplatform .platform() .startswith( 'Windows '):
logging_file =os.path .join(os .getenv( 'HOMEDRIVE '), \
(продолжениенаследующейстранице)
17.2. Модуль logging 133A Byte of Python (Russian), Версия 2.02
(продолжениеспредыдущейстраницы)
os.getenv( 'HOMEPATH '), \
'test.log ')
else :
logging_file =os.path .join(os .getenv( 'HOME '),'test.log ')
print ("Сохраняем лог в ", logging_file)
logging .basicConfig(
level =logging .DEBUG,
format ='%(asctime)s :%(levelname)s :%(message)s ',
filename =logging_file,
filemode ='w',
)
logging .debug( "Начало программы ")
logging .info( "Какие-то действия ")
logging .warning( "Программа умирает ")
Вывод:
$ python3 use_logging.py
Сохраняем лог в C:\Users\swaroop\test.log
Еслиоткрытьфайл test.log ,онбудетвыглядетьпримернотак:
2012 -10-2616:52:41,457 : DEBUG : Начало программы
2012 -10-2616:52:41,474 : INFO : Какие -то действия
2012 -10-2616:52:41,475 : WARNING : Программа умирает
Как это работает:
Мыиспользовалитримодуляизстандартнойбиблиотеки:модуль osдлявза-
имодействиясоперационнойсистемой,модуль platform дляполученияин-
формации о платформе (т.е. операционной системе) и модуль logging для
сохранениялога1.
Прежде всего, при помощи строки, возвращаемой функцией platform.
platform() мы проверяем, какая операционная система используется (для
болееподробнойинформациисм. import platform; help(platform) ).Ес-
лиэтоWindows,томыопределяемдиск,содержащийдомашнийкаталог,путь
к домашнему каталогу на нём и имя файла, в котором хотим сохранить ин-
формацию. Сложив все эти три части, мы получаем полный путь к файлу.
Для других платформ нам нужно знать только путь к домашнему каталогу
пользователя,имыполучимполныйпутькфайлу.
1log– англ.«журнал»,«вестижурнал»( прим.перев. )
17.2. Модуль logging 134A Byte of Python (Russian), Версия 2.02
При помощи функции os.path.join() мы объединяем три части пути к
файлу вместе. Мы используем эту функцию вместо простого объединения
строкдлятого,чтобыгарантировать,чтополныйпутькфайлузаписанвфор-
мате,ожидаемомоперационнойсистемой.
Далеемыконфигурируеммодуль loggingтакимобразом,чтобыонзаписы-
валвсесообщениявопределённомформатевуказанныйфайл.
Наконец,мыможемвыводитьсообщения,предназначенныедляотладки,ин-
формирования, предупреждения и даже критические сообщения. После вы-
полнения программы можно просмотреть этот файл и узнать, что происхо-
дило в программе, хотя пользователю, запустившему программу, ничего не
былопоказано.
17.3
Серия «Модуль недели»
Встандартнойбиблиотекеможнонайтиещёмногополезного.Например, отладка,обра-
боткапараметровкоманднойстроки ,регулярныевыражения итакдалее.
Лучшийспособдальнейшегоизучениястандартнойбиблиотеки–читатьзамечательную
сериюДугаХелмана «Модульнедели» илиофициальную документациюPython .
17.4
Резюме
Мыизучилилишьнекоторыевозможностинекоторыхмодулейстандартнойбиблиотеки
Python.Янастоятельнорекомендуюпросмотреть документациюпостандартнойбиблио-
текеPython ,чтобыувидетьвседоступныемодули.
Далеемыобратимсякнекоторымаспектам,которыесделаютвашуэкскурсиюпоPython
более«завершённой».
17.3. Серия «Модуль недели» 135Дополнительно
К настоящему моменту мы уже рассмотрели большую часть того, что вам придётся ис-
пользовать при работе с Python. В этой главе мы охватим некоторые дополнительные
аспекты,которыепомогутотшлифоватьвашизнания.
18.1
Передача кортежей
Хотелосьливамкогда-нибудь,чтобыфункциявозвращаланеодинрезультат,адва?Это
возможно.Всё,чтодляэтогонужно,–использоватькортеж.
>>> def get_error_details ():
... return (2,'описание ошибки No2 ')
...
>>> errnum, errstr =get_error_details()
>>> errnum
2
>>> errstr
'описание ошибки No2'
Обратитевнимание,чтоиспользованиевыражения« a, b = <некоторое выражение> »
интерпретируетрезультаткаккортежиздвухзначений.
Чтобыинтерпретироватьрезультаткак« (a, <всё остальное>) »,нужнопростопоста-
витьзвёздочку,какэтоделалосьдляпараметровфункций:
>>> a,*b=[1,2,3,4]
>>> a
1
>>> b
[2, 3, 4]
Это также подразумевает, что поменять местами два значения в Python быстрее всего
можнотак:
136A Byte of Python (Russian), Версия 2.02
>>> a=5; b =8
>>> a, b =b, a
>>> a, b
(8, 5)
18.2
Специальные методы
Естьрядметодов,играющихособуюрольдляклассов.Например, __init__ и__del__.
Специальныеметодыслужатдлятого,чтобыимитироватьповедениевстроенныхтипов
данных. Например, всё, что потребуется для использования операции индексирования
x[индекс] применительно к своему классу (в таком виде, как это делалось для списков
и кортежей), это реализовать метод __getitem__() . Кстати, именно этот метод Python
используетдлясамогокласса list!
Некоторыеполезныеспециальныеметодыперечисленывтаблицениже.Вседругиеме-
тодыможнопосмотретьв документации .
Имя Описание
__init__(self,…) Этотметодвызываетсяпрямопередтем,каквновьсозданный
объектвозвращаетсядляиспользования.
__del__(self) Вызываетсяпередуничтожениемобъекта
__str__(self) Вызываетсяприиспользованиифункции printилиstr().
__lt__(self,other) Вызывается,когдаиспользуетсяоператор«меньше»(<).
Существуютианалогичныеметодыдлявсехоператоров(+,>,
ит.д.)
__getitem__(self,key) Вызываетсяприиспользованииоператораиндексирования
x[индекс]
__len__(self) Вызываетсяприобращенииквстроеннойфункции len()для
объекта-последовательности.
18.3
Блоки в одно выражение
Мы неоднократно говорили, что каждый блок команд отделяется от других своим соб-
ственнымуровнемотступа.Однако,существуетиисключение.Еслиблоккомандсодер-
життолькоодновыражение,егоможноуказыватьводнойстрокесусловнымоператором
или,скажем,операторомцикла.Рассмотримэтонапримере:
>>> flag =True
>>> ifflag: print ('Да')
Да
18.2. Специальные методы 137A Byte of Python (Russian), Версия 2.02
Обратитевнимание,чтоединственныйоператоррасположенвтойжестроке,анеотдель-
нымблоком.Этотспособможетподкупитьтем,чтоякобы«сокращает»программу,ноя
настоятельнорекомендуюизбегатьегововсехслучаях,кромепроверкиошибок.Прежде
всего,потомучтогораздолегчедобавлятькоманды,когдаужеестьнеобходимыйуровень
отступа.
18.4
Lambda-формы
Ключевое слово lambdaиспользуется для создания функций и возврата их значения во
время выполнения программы. lambdaпринимает параметр, за которым следует одно
выражение, которое становится телом функции, а значение этого выражения возвраща-
етсяновойфункцией.
Пример: (сохранитекак lambda.py )
points =[ { 'x':2,'y':3}, { 'x':4,'y':1} ]
points .sort(key =lambda i : i[ 'y'])
print (points)
Вывод:
$ python3 lambda.py
[{'x': 4, 'y': 1}, {'x': 2, 'y': 3}]
Как это работает:
Обратитевниманиенато,чтометод sortкласса listможетприниматьпара-
метр key,определяющийспособсортировкисписка(обычномыдумаемтоль-
коосортировкеповозрастаниюилипоубыванию).Вданномслучаемыхотим
провести сортировку по собственному принципу, для чего нам необходимо
написатьсоответствующуюфункцию.Новместотого,чтобысоздаватьотдель-
ныйблок defдляописанияфункции,котораябудетиспользоватьсятольков
этомместе,мыприменяемлямбда-выражение.
18.5
Генераторы списков
Генераторысписковслужатдлясозданияновыхсписковнаосновесуществующих.Пред-
ставьте,чтоимеетсясписокчисел,наосновекотороготребуетсяполучитьновыйсписок,
состоящийизвсехчисел,умноженныхна2,нотолькоприусловии,чтосамочислоболь-
ше2.Генераторысписковподходятдлятакихзадачкакнельзялучше.
18.4. Lambda-формы 138A Byte of Python (Russian), Версия 2.02
Пример: (сохранитекак list_comprehension.py )
listone =[2,3,4]
listtwo =[2*ifor iinlistone ifi>2]
print (listtwo)
Вывод:
$ python3 list_comprehension.py
[6, 8]
Как это работает:
Вэтомпримеремысоздаёмновыйсписок,указавоперацию,которуюнеобхо-
димо произвести ( 2 * i), когда выполняется некоторое условие ( if i > 2 ).
Обратитевнимание,чтоисходныйсписокприэтомнеизменяется.
Преимуществоиспользованиягенераторовсписковсостоитвтом,чтоэтозаметносокра-
щаетобъёмыстандартногокода,необходимогодляциклическойобработкикаждогоэле-
ментаспискаисохраненияеговновомсписке.
18.6
Передача кортежей и словарей в функции
Дляполученияпараметров,переданныхфункции,ввидекортежаилисловаря,существу-
ютспециальныеприставки« *»или« **»соответственно.Этоособеннополезновслуча-
ях,когдафункцияможетприниматьпеременноечислопараметров.
>>> def powersum (power, *args):
... '''Возвращает сумму аргументов, возведённых в указанную степень.'''
... total =0
... for iinargs:
... total +=pow(i, power)
... return total
...
>>> powersum( 2,3,4)
25
>>> powersum( 2,10)
100
Поскольку перед переменной argsуказана приставка « *», все дополнительные аргу-
менты, переданные функции, сохранятся в argsв виде кортежа. В случае использова-
ния приставки « **» все дополнительные параметры будут рассматриваться как пары
ключ/значениевсловаре.
18.6. Передача кортежей и словарей в функции 139A Byte of Python (Russian), Версия 2.02
18.7
exec и eval
Функция execслужитдлявыполнениякомандPython,содержащихсявстрокеилифай-
ле,вотличиеотсамоготекстапрограммы.Например,вовремявыполненияпрограммы
можно сформировать строку, содержащую текст программы на Python, и запустить его
припомощи exec:
>>> exec( 'print( "Здравствуй, Мир! ")')
Здравствуй, Мир!
Аналогично, функция evalпозволяет вычислять корректные выражения Python, содер-
жащиесявстроке.Вотпростойпример.
>>> eval ('2*3')
6
18.8
Оператор assert
Оператор assertсуществует для того, чтобы указать, что нечто является истиной. На-
пример, если требуется гарантировать, что в списке будет хотя бы один элемент, и вы-
зватьошибку,еслиэтонетак,тооператор assertидеальноподойдётдлятакойзадачи.
Когдазаявленноевыражениеложно,вызываетсяошибка AssertionError .Метод pop()
возвращаетпоследнийэлементсписка,одновременноудаляяегооттуда.
>>> mylist =['item ']
>>> assert len(mylist) >=1
>>> mylist .pop()
'item'
>>> mylist
[]
>>> assert len(mylist) >=1
Traceback (most recent call last):
File "<stdin>" , line 1, in <module>
AssertionError
Темнеменее,оператор assertследуетиспользоватьблагоразумно.Вбольшинствеслу-
чаев гораздо лучше «отлавливать» исключения и либо решать соответствующую про-
блему автоматически, либо выдавать пользователю сообщение об ошибке и завершать
работупрограммы.
18.7. exec и eval 140A Byte of Python (Russian), Версия 2.02
18.9
Функция repr
Функция reprиспользуется для получения канонического строкового представления
объекта.Любопытно,чтовбольшинствеслучаев eval(repr(object)) == object .
>>> i=[]
>>> i.append( 'item ')
>>> repr (i)
"['item']"
>>> eval (repr (i))
['item']
>>> eval (repr (i)) ==i
True
По большому счёту, функция reprслужит для получения печатаемого представления
объекта. Определив метод __repr__ в собственном классе, можно указать, что он будет
возвращатьповызовуфункции repr.
18.10
Управляющие последовательности
Попробуйтеответитьнавопрос:Какуказатьстроку,содержащуюодинарнуюкавычку( ')?
Например,строку« What's your name? ».Еёведьнельзязаписатьпростокак« 'What's
your name?' »,потомучтотогдаPythonнесможетопределить,гденачалостроки,игде
конец.Втакомслучаепридётсякаким-тообразомуказать,чтоданнаяодинарнаякавычка
не обозначает конца строки. Это можно сделать при помощи так называемой управляю-
щей последовательности . Укажите одинарную кавычку как \'– через обратную косую
черту.Теперьнашастрокабудетвыглядетьтак: 'What\'s your name?' .
Другой способ записи такой специфической строки – "What's your name?" , т.е. с ис-
пользованиемдвойныхкавычек.Аналогичноследуетиспользоватьуправляющуюпосле-
довательностьдлявставкидвойнойкавычкивстроку,ограниченнуюдвойнымикавычка-
ми.Самажеобратнаянаклоннаячертауказываетсяуправляющейпоследовательностью
\\.
А как записать двустрочную строку? Один из вариантов нам уже знаком – заключить
строку в тройные кавычки, как было показано ранее. Но есть и другой – использовать
управляющую последовательность для символа перевода строки \n. Например: « Это
первая строка\nЭто вторая строка ». Полезно знать ещё одну управляющую после-
довательность–табуляцию( \t).Управляющихпоследовательностейсуществуетнамного
больше,ноздесьупомянутытольконаиболееважные.
Следуетотметить,чтоодинарнаянаклоннаячертавконцестрокилишьуказываетнато,
чтопродолжениеидётстрокойниже,ноневставляетпереводастроки.Например:
18.9. Функция repr 141A Byte of Python (Russian), Версия 2.02
"Это первое предложение. \
Это второе предложение. "
эквивалентнозаписи "Это первое предложение. Это второе предложение." .
18.11
Необрабатываемые строки
Длязаписистроки,вкоторойнебудетпроводитьсяникакойспециальнойобработки,как,
например,управляющихпоследовательностей,передстрокойуказываетсяприставка« r»
или« R»1.Например, r"Перевод строки обозначается \n" .
Замечание для пользователей регулярных выражений
Дляработысрегулярнымивыражениямивсегдаиспользуйтенеобрабатываемыестроки.
Впротивномслучаевасждётмноговознисобратнымикосымичёрточками.Например,
обратныессылкиможнообозначатькак '\\1'илиr'\1'.
18.12
Резюме
Итак, в настоящей главе мы рассмотрели некоторые дополнительные возможности
Python, хотя по-прежнему, не охватили всего. Тем не менее, к настоящему моменту мы
ужепрошлипочтивсё,чтовамкогда-либопонадобитсяиспользоватьнапрактике.Этого
вполнедостаточнодляначалаработынадлюбымипрограммами.
Далеемыобсудим,какпродолжатьисследоватьPython.
1«r»– от англ.«raw»–«сырой,необработанный»( прим. перев. )
18.11. Необрабатываемые строки 142Что дальше
Добросовестный читатель, дочитавший книгу до сих пор, а также много практиковав-
шийся в написании программ, наверняка уже освоился с Python. И конечно, вы уже по-
пробовалиреализоватькакие-нибудьсобственныеидеинаPython,чтобыпотренировать-
ся.Нет?Тогдастоитначать!Новтакомслучаевозникаетвопрос:«Чтожеделатьдальше?».
Япредлагаювамсправитьсясоследующейзадачей.
Задача
Создайте собственную программу «Адресная книга», работающую из командной стро-
киипозволяющуюпросматривать,добавлять,изменять,удалятьилиискатьконтактные
данныевашихзнакомых.Крометого,этаинформациятакжедолжнасохранятьсянадис-
кедляпоследующегодоступа.
Это достаточно простая задача, если думать о ней в терминах, которые мы до сих пор
проходили.Еслижевывсё-такинуждаетесьвподсказке,какдействовать,вотона.
Подсказка (не читать!)
Создайтеклассдляхраненияперсональныхданных.Объектывизитныхкарточекхрани-
те в словаре, в котором имена контактов будут служить ключами. Для длительного хра-
нения этих объектов на жёстком диске воспользуйтесь модулем pickle. Для добавления,
измененияилиудаленияконтактовприменяйтевстроенныеметодысловаря.
Кактольковысправитесьсэтим,высмеломожетеназыватьсяпрограммистомнаPython.
А теперь немедленно напишите мне письмо ;-).Это не обязательный шаг, но весьма ре-
комендуемый. Также подумайте о покупке бумажной версии книги , чтобы поддержать
еёдальнейшуюразработку.
Еслиэтазадачкапоказаласьвамслишкомлёгкой,попробуйтеещёодну:
143A Byte of Python (Russian), Версия 2.02
Задача
Реализуйтекоманду replace.Этакомандазаменяетоднустрокудругойвспискепередан-
ныхейфайлов.
Команда replaceможет быть любой желаемой сложности: от простой замены строк до
поискапошаблону(регулярномувыражению).
Авотещёнекоторыевозможныенаправлениявашегодальнейшегопутешествияпомиру
Python:
19.1
Упражнения
На Stack Overflow есть неплохое обсуждение упражнений на Python, помогающих отто-
читьвашемастерство .
19.2
Примеры программ
Лучшийспособовладетьязыкомпрограммирования–этописатьмногопрограммичи-
татьмногопрограмм:
•ПроектPLEAC
•ХранилищекодаRosetta
•ПримерыдляPythonнаjava2s
•Книга рецептов Python – ценнейшая коллекция рецептов и подсказок, как решать
теилииныепроблемыприпомощиPython.Обязательнакпрочтениюкаждымпро-
граммистомнаPython.
•Модуль недели – ещё один замечательный путеводитель по стандартной библио-
теке Python .
19.3
Вопросы и ответы
•Официальные«Можноинельзя»вPython
•ОфициальныеЧаВоPython
•СписокНеЧастозадаваемыхВопросовотNorvig
•ВопросыиответыизинтервьюоPython
19.1. Упражнения 144A Byte of Python (Russian), Версия 2.02
•ВопросынаStackOverflowспометкой«python»
19.4
Советы и рекомендации
•ТрюкииуловкиPython
•СколачиваемпрограммыприпомощиPython
•ОчаровательныйPython –замечательнаясериястатейоPythonДэвидаМерца.
19.5
Учебники
•ВсеобъемлющийсписокучебниковпоPythonотAwaretek
19.6
Видео
•PyVideo
19.7
Обсуждение
Есливызастрялинакакой-топроблемевPythonинезнаете,когоспросить,тогда список
рассылкиpython-tutor подойдётнаилучшимобразом.
Темнеменее,сначалапроделайтевсюдомашнююработуипопытайтесьрешитьпробле-
мусамостоятельно.
19.8
Новости
ЕсливасинтересуютпоследниеновостимираPython,отслеживайтеихнаофициальной
планетеPython .
19.4. Советы и рекомендации 145A Byte of Python (Russian), Версия 2.02
19.9
Установка библиотек
ВКаталогепакетовPython существуетколоссальноеколичествооткрытыхбиблиотек,ко-
торыевыможетеиспользоватьвсвоихпрограммах.Дляихустановкиможновоспользо-
ватьсяpip.
19.10
Графические программы
ДлясозданиясобственнойграфическойпрограммынаPythonпонадобитсякакая-нибудь
библиотека ГИП (графического интерфейса пользователя) со своими привязками к
Python. Привязки позволяют писать программу на Python, используя библиотеки, кото-
рыесамипосебенаписанынаC,C++илидругихязыках.
ВыборГИПдляPythonдостаточнообширен:
•Kivy
http://kivy.org
•PyGTK
Это привязки Python к инструментарию GTK+, на основе которого построен
GNOME. У GTK+ есть много своих особенностей, но как только вы освоитесь, вы
сможетесоздаватьГИПоченьбыстро.Чтокасаетсядизайнераграфическогоинтер-
фейсаGlade,тоонпростонезаменим.Документацияжевсёещётребуетнекоторых
улучшений. GTK+ хорошо работает в GNU/Linux, но его порт на Windows пока не
закончен.ПрипомощиGTK+можносоздаватькаксвободные,такипроприетарные
программы.Дляначалапрочитайте УчебникпоPyGTK .
•PyQt
Это привязки Python к инструментарию Qt, на основе которого построена KDE. Qt
чрезвычайнопроствиспользовании,особенноблагодаряQtDesignerиизумитель-
нойдокументацииQt.PyQtбесплатно,еслииспользуетсядлясозданиясвободных
программ(слицензиейGPL).Длясозданиязакрытыхпроприетарныхпрограммвам
придётсяегокупить.НачинаясQt4.5,разрешаетсясоздаватьприпомощинегоне
только GPL’ные программы. Для начала прочитайте краткое пособие по PyQt или
КнигуPyQt .
•wxPython
ЭтопривязкиPythonкинструментариюwxWidgets.wxPythonнетакпроствосвое-
нии,нозатоонпереносимиработаетнаGNU/Linux,Windows,Macидаженавстраи-
ваемыхплатформах.МногиесредыразработкидляwxPython,такиекак SPE(Stani’s
Python Editor) иwxGladeвключают дизайнеры графического интерфейса. При по-
мощиwxPythonможносоздаватькаксвободные,такипроприетарныепрограммы.
Дляначалапрочитайте учебникпоwxPython .
19.9. Установка библиотек 146A Byte of Python (Russian), Версия 2.02
19.11
Резюме по инструментам ГИП
Другие варианты можно найти на wiki-странице GuiProgramming официального сайта
Python.
К сожалению, не существует некоего единого стандартного инструмента для создания
графических программ на Python. Я бы рекомендовал выбирать один из инструментов,
описанных выше, наиболее подходящий для конкретной ситуации. Во-первых, опреде-
литесь, согласны ли вы платить за использование этого инструмента. Во-вторых, опре-
делитесь,накакихплатформахдолжнаработатьвашапрограмма:тольконаWindows,на
MacиGNU/Linuxилинавсехсразу.Ив-третьих,есливывыбралиплатформуGNU/Linux,
товкакойсредевыработаете:вKDEилиGNOME.
Дляболееподробногоанализасм.страницу26 СтатейоPython,Том3,Выпуск1 .
19.12
Различные реализации
Языкпрограммированияобычносостоитиздвухчастей:собственноязыкаипрограмм-
ногообеспечения.Язык–этото, какмычто-либопишем,апрограммноеобеспечение–
этото, чтозапускаетнашипрограммы.
До сих пор для выполнения наших программ мы использовали CPython. Он называется
«CPython», потому что написан на языке C и является Классическим интерпретатором
Python1.
Носуществуетидругоепрограммноеобеспечение,способноевыполнятьпрограммына
Python:
•Jython
Реализация Python, работающая на платформе Java. Это означает, что можно ис-
пользоватьбиблиотекииклассыJavaвпрограмменаPythonинаоборот.
•IronPython
РеализацияPython,работающаянаплатформе.NET,чтоозначаетвозможностьис-
пользованиябиблиотекиклассов.NETвпрограммахнаPythonинаоборот.
•PyPy
Реализация Python, написанная на Python! Это исследовательский проект, суще-
ствующийдляускоренияиоблегченияразработкиинтерпретатора,посколькусам
интерпретаторнаписаннадинамическомязыке(вотличиеотстатическихязыков,
какC,JavaиC#ввышеупомянутыхреализациях)
•StacklessPython
1Classical Pythoninterpreter( прим.перев. )
19.11. Резюме по инструментам ГИП 147A Byte of Python (Russian), Версия 2.02
Реализация Python, специализирующаяся на высокой производительности много-
поточныхпрограмм.
Существуют и другие реализации, такие как CLPython – написанная на Common Lisp и
IronMonkey –портIronPythonнаJavaScript,чтодаётвозможностьписатьбраузерныепри-
ложения(«Ajax»)наPythonвместоJavaScript.
Каждаяизперечисленныхреализацийимеетсвоюобластьприменения.
19.13
Функциональное программирование (для хо-
рошо подготовленных читателей)
Для написания больших программ определённо необходимо изучить функциональный
подход к программированию, в отличие от объектно-ориентированного подхода, кото-
рыймыпроходилив разделе «Объектно-ориентированное программирование» :
•Практическиесоветыпофункциональномупрограммированию,A.M.Kuchling
•Глава«Функциональноепрограммирование»книги«DiveIntoPython»
•Презентация«ФункциональноепрограммированиевPython»
19.14
Резюме
Вотмыиподошликконцунашейкниги,нокакговорится,этотолько начало конца !Те-
перьвызаядлыйпрограммистнаPython,инесомненно,готовырешатьмножествозадач
при помощи Python. Теперь вы можете начать автоматизировать на своём компьютере
всёподряд,можетеписатьсобственныеигрыимногое-многоедругое.Такчтовперёд!
19.13. Функциональное программирование (для хорошо подготовленных
читателей)148Приложение: FLOSS
20.1
Free/Libre and Open Source Software (FLOSS)1
В основу идеи FLOSSположена концепция сообщества, в котором принято делиться, и
особенноделитьсязнаниями.Свободныепрограммыможносвободноиспользовать,из-
менятьираспространять.
Есливыужепрочлиэтукнигу,товыужезнакомысосвободнымПО,таккаквыизучали
Pythonвсёэтовремя,аPythonявляетсясвободнымпрограммнымобеспечением!
Вот несколько примеров свободного ПО, по которым можно составить некоторое пред-
ставлениеотом,чтоспособносоздатьтакоесообщество:
•Linux.Этосвободноеядрооперационнойсистемы,используемое,например,вопе-
рационной системе GNU/Linux. Разработку ядра «Linux» начал Линус Торвальдс
ещёвсвоюбытностьстудентом.[ LinuxKernel ]
•GNU. Свободная операционная система, основанная Ричардом Столлманом в 1983
году.[GNU]
•GNU/Linux . Сочетание операционной системы GNU с ядром «Linux», в наше вре-
мя серьёзный конкурент Microsoft Windows. В принципе, GNU/Linux является сво-
бодным программным обеспечением, но разные дистрибутивы GNU/Linux могут
включатьинесвободныепрограммы.[ FreeGNU/Linuxdistributions ]
•Ubuntu. Это дистрибутив, разрабатываемый сообществом и спонсируемый фир-
мой Canonical. В настоящее время это, пожалуй, самый популярный дистрибутив
GNU/Linux. Он позволяет легко устанавливать и использовать множество свобод-
ных программ. Больше того, он позволяет просто перезагрузить ваш компьютер и
запуститьGNU/LinuxсCD!Этодаётвозможностьвполноймереопробоватьновую
операционную систему до установки на жёсткий диск. Однако, Ubuntu не полно-
стьюсвободна,таккаквключаетнекоторыепроприетарныедрайверы,микрокоди
приложения.[ Ubuntu]
•LibreOffice . Это превосходный офисный пакет, разрабатываемый сообществом и
включающий в себя компоненты для создания текста, презентаций, электронных
1Свободноеиоткрытоепрограммноеобеспечение( прим.перев. )
149A Byte of Python (Russian), Версия 2.02
таблиц, рисунков и многого другого. Он также позволяет открывать и редактиро-
вать файлы MS Word и MS Powerpoint. Он работает практически на всех платфор-
мах и является полностью свободным и открытым программным обеспечением.
[LibreOffice ]
•Mozilla Firefox .Этовеб-браузерновогопоколения,являющийсясильнейшимсопер-
никомInternetExplorer.Оногненнобыстр,изаработалширокоепризнаниесвоими
удобнымиивпечатляющимивозможностями.Аконцепциярасширенийпозволяет
дополнятьегосамымиразнообразнымиплагинами.[ MozillaFirefox ]
•Его«напарник» Thunderbird –отличныйклиентэлектроннойпочты,делающийеё
чтениечрезвычайнопростым.[ MozillaThunderbird ]
•Mono. Это свободная реализация платформы Microsoft .NET. Она позволяет созда-
ватьизапускать.NET-приложениявGNU/Linux,Windows,FreeBSD,MacOSинамно-
гихдругихплатформах.[ Mono],[ECMA],[.NET]
•Apache web server . Это популярный открытый веб-сервер. По сути, это самыйпо-
пулярныйвеб-сервернапланете.Нанёмработаетболееполовинывсехсайтов.Да,
Apacheдействительнообслуживает большесайтов,чем всеостальные веб-серверы
(включаяMicrosoftIIS)вместевзятые.[ Apache]
•MySQL. Это чрезвычайно популярный открытый сервер баз данных. Он наиболее
известенсвоейошеломляющейскоростью.Этоегообозначаютбуквой«M»всоче-
тании«LAMP»,накоторомработаетбольшинствосайтоввИнтернете.[ MySQL]
•VLC Player . Это проигрыватель, который может воспроизводить всё, начиная от
DivX и до MP3, до Ogg, до VCD, до DVD, до … и кто сказал, что это не забавно?
;-)[VLCmediaplayer ]
•GeexBox – дистрибутив GNU/Linux, созданный для проигрывания фильмов сразу
послезагрузкисCD![ GeexBox]
Этот список предназначен только лишь для того, чтобы вкратце передать вам мысль,
на самом же деле существует ещё огромное множество свободного ПО, такого как язык
Perl, язык PHP, система управления содержимым веб-сайтов Drupal, сервер баз данных
PostgreSQL, игра TORCS, среда разработки KDevelop, проигрыватель Xine, текстовый ре-
дакторVIM,редакторQuanta+,аудио-плеерBanshee,графическийредакторGIMP,…этот
списокможнопродолжатьвечно.
ЧтобыотследитьсвежиеслухивмиресвободногоПО,посетитеследующиесайты:
•linux.com
•LinuxToday
•NewsForge
•DistroWatch
УзнатьбольшеосвободномПОможнонаследующихсайтах:
20.1. Free/Libre and Open Source Software (FLOSS)1150A Byte of Python (Russian), Версия 2.02
•SourceForge
•FreshMeat
Такчтовперёд–осваиватьбескрайний,свободныйиоткрытыймирСПО!
20.1. Free/Libre and Open Source Software (FLOSS)1151Приложение: о книге
21.1
Колофон
Практическивсепрограммы,которыеяиспользовалпринаписанииэтойкниги,являются
свободными .
21.1.1
Рождение книги
При написании первого черновика этой книги в основе моей системы была Red Hat 9.0
Linux,ноужешестуюверсиючерновикаяписалнаFedoraCore3Linux.
ВначаледлянаписаниякнигияиспользовалKWord(какяиописывалв Предисловии ).
21.1.2
Отрочество
Позже я перешёл на формат DocBook XML и использовал Kate, но это показалось мне
слишком скучным. Поэтому я перешёл на OpenOffice, который замечательно подходил
со своим уровнем управления форматированием и возможностью генерировать PDF, но
онвыдавалслишкомнебрежныеHTML-страницы.
Наконец,яоткрылдлясебяXEmacsипереписалвсюкнигуснулявформатеDocBookXML
(снова),таккакрешил,чтоэтотформат–надолго.
Для шестой версии черновика я решил использовать Quanta+. При этом я использовал
стандартныетаблицыстилейXSL,которыешливкомплектесFedoraCore3Linux.Потом
я написал CSS документ, чтобы придать цвет и стиль HTML-страницам. Я также на ско-
рую руку написал лексический анализатор (конечно, на Python), который осуществлял
автоматическуюподсветкусинтаксисавпримерахпрограмм.
Для седьмой редакции я использовал MediaWiki в качестве основы для своего сай-
та. Теперь я всё редактирую прямо на сайте, а читатели могут сразу же чи-
тать/редактировать/обсуждатьсодержимоенавики-странице.
Благодаря расширению ViewSourceWith для Firefox , которое интегрируется с Vim, я про-
должалиспользоватьVimдляредактирования.
152A Byte of Python (Russian), Версия 2.02
21.1.3
Сейчас
Использую Vim,Pandoc,иMacOSX.
21.2
Об авторе
http://www.swaroopch.com/about/
21.2. Об авторе 153Приложение: История версий
•2.0(20/10/2012)
–Переписановформате PandocСпасибомоейжене,котораяперевелабольшую
частьтекстаизформатаMediawiki
–Упрощениетекста,удалениетакихнеобязательныхразделов,как nonlocal и
метаклассы
•1.90(04/09/2008)
–Возобновлениепослеперерывав3.5года!
–ОбновлениедляPython3.0
–Переписановформате MediaWiki (снова)
•1.20(13/01/2005)
–Полностьюпереписанов Quanta+наFedoraCore3сомножествомисправлений
идополнений.Многоновыхпримеров.ЗановопереписанформатDocBook.
•1.15(28/03/2004)
–Незначительныеисправления.
154A Byte of Python (Russian), Версия 2.02
•1.12(16/03/2004)
–Дополненияиисправления.
•1.10(09/03/2004)
–Исправленияопечаток,благодарямножествуотзывовзаинтересованныхчита-
телей.
•1.00(08/03/2004)
–После колоссального числа отзывов и предложений от читателей я произвёл
значительнуюпереработкутекстанарядусисправлениемопечаток.
•0.99(22/02/2004)
–Добавленановаяглаваомодулях.Такжедобавленфрагментопеременномчис-
леаргументоввфункциях.
•0.98(16/02/2004)
–Написан скрипт на Python и таблица стилей CSS для улучшения вывода в
XHTML, включая недоделанный-но-функциональный лексический анализа-
тордляподсветкисинтаксисавпримерахпрограмм
•0.97(13/02/2004)
–Ещё один заново переписанный черновик в формате DocBook XML (снова).
Книгасущественноулучшена–онасталазначительноболеесвязаннойичи-
табельной.
155A Byte of Python (Russian), Версия 2.02
•0.93(25/01/2004)
–ДобавленоописаниеIDLEидругиевещи,относящиесякWindows.
•0.92(05/01/2004)
–Изменениявнесколькихпримерах.
•0.91(30/12/2003)
–Исправленыопечатки.Сделанынаброскимногихразделов.
•0.90(18/12/2003)
–Добавлены2главы.Формат OpenOffice сисправлениями.
•0.60(21/11/2003)
–Полностьюпереписаноирасширено.
•0.20(20/11/2003)
–Исправленынекоторыеопечаткииошибки.
156A Byte of Python (Russian), Версия 2.02
•0.15(20/11/2003)
–Переведеновформат DocBookXML припомощиXEmacs.
•0.10(14/11/2003)
–Самыйпервыйнабросоквредакторе KWord.
157Приложение: Инструкция по переводу
ПолныйисходныйтексткнигидоступенвGit-репозитории https://github.com/swaroopch/
byte_of_python .
Создайтеответвлениерепозитория .
Затемскачайтерепозиторийнасвойкомпьютер.Дляэтогонужнобытьзнакомымс Git.
Отредактируйтефайлы .pdнасвоёмродномязыке.Прочитайте PandocREADME ,чтобы
познакомитьсясформатированиемтекста
Затемследуйтеуказаниямв README дляустановкипрограмм,необходимыхдляконвер-
тированияисходныхфайловвPDFит.п.
158